# 28. 오류처리

대부분의 프로그래밍 언어는 프로그램에서 발생하는 오류에 대비하기 위해 오류를 처리하는 기능을 제공한다. 스위프트도 오류를 적절히 처리할 수 있는 기능을 제공한다. 스위프트가 제공하는 오류처리 기능에 대해 알아보자.

## 28.1 오류처리란

**오류처리** 는 프로그램이 오류를 일으켰을 때 이것을 감지하고 회복시키는 일련의 과정이다.

프로그램에서 모든 기능이 우리가 원하는대로 100% 정확히 동작한다는 보장은 없다. 특히나 전달받아야 하는 값이 까다롭거나 데이터를 가공하는 데 소비하는 자원이 많을 경우 오류가 발생할 확률이 높아진다. 이런 가능성이 있는 기능을 구현할 때는 오류가 발생할 수 있음을 항상 고려해야 한다.

예를 들어 디스크의 파일을 읽어오는 기능을 생각해보자. 파일이 존재하지 않을 수도 있으며, 읽기 권한이 없을 수도 있고, 잘못된 파일일 가능성도 있다. 이렇게 파일을 읽어오는 간단한 기능에서도 오류가 발생할 수 있는 가능성이 여럿 존재한다. 오류처리 기능을 통해 이런 상황들을 구별하여 프로그램 자체적으로 오류를 해결할 수 있고, 사용자와 상호작용을 통해 오류를 어떤 방향으로 풀어나갈지 제어할 수도 있다.

다만 주의할 점은 스위프트의 오류처리 기능을 통해 시스템(예를 들어 운영체제 등 우리가 작성하는 응용프로그램 외부)에서 발생한 오류를 처리할 수 있는 것이 아님을 명시해야 한다.

## 28.2 오류의 표현

스위프트에서 오류는 Error라는 프로토콜을 준수하는 타입의 값을 통해 표현된다. Error 프로토콜은 사실상 요구사항이 없는 빈 프로토콜일 뿐이지만, 오류를 표현하기 위한 타입(주로 열거형)은 이 프로토콜을 채택한다.

스위프트의 열거형은 오류의 종류를 나타내기에 아주 적합한 기능이다. 연관 값을 통해 오류에 관한 부가 정보를 제공할 수도 있다. 다음 코드는 프로그램 내에서 자판기를 작동시키려고 할 때 발생하는 오류의 종류를 열거형으로 표현한 것이다.

```swift
enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
```

VendingMachineError 열거형을 살펴보면 Error 프로토콜을 채택함으로써 오류처리를 위한 타입임을 알 수 있다. 그리고 이 코드에서 오류의 종류는 invalidSelection(유효하지 않은 선택), insufficientFunds(coinsNeeded: Int) (자금 부족 - 필요한 동전 개수), outOfStock(품절) 등 세 가지가 있다. 이처럼 열거형을 통해 오류의 종류를 표현하는 것이 가장 일반적이며 편리한 방법이다.

이렇게 오류의 종류를 미리 예상한 다음, 오류 때문에 다음에 행할 동작이 정상적으로 진행되지 않을 때라면 **오류를 던져** 주면 된다. 오류를 던져줄 때는 throw 구문을 사용한다. 만약 자금이 부족하고 동전이 5개 더 필요한 상황이라면 throw VendingMachineError.insufficientFunds(coinsNeeded: 5) 라고 오류를 던져줄 수 있다.

이제 던져진 오류를 포착하고 처리하는 방법을 알아보자.

## 28.3 오류 포착 및 처리

오류를 던질 수도 있지만 오류가 던져지는 것에 대비하여 던져진 오류를 처리하기 위한 코드도 작성해야 한다. 예를 들어 던져진 오류가 무엇인지 판단하여 다시 문제를 해결한다든지, 다른 방법으로 문제 해결을 시도해 본다든지, 오류를 알리고 사용자에게 선택 권한을 넘겨주어 다음에 어떤 동작을 하게 할 것인지 결정하도록 유도하는 등의 코드를 작성해야 한다.

스위프트에는 오류를 처리하기 위한 네 가지 방법이 있다.

* 함수에서 발생한 오류를 해당 함수를 호출한 코드에 알리는 방법
* do-catch 구문을 이용하여 오류를 처리하는 방법
* 옵셔널 값으로 오류를 처리하는 방법
* 오류가 발생하지 않을 것이라고 확신하는 방법

각각의 방법에 대해 알아보도록 하겠다.

### 28.3.1 함수에서 발생한 오류 알리기

먼저 함수에서 발생한 오류를 해당 암수를 호출한 코드에 알리는 방법이다. 함수가 오류를 던지면 프로그램의 흐름이 바뀔 가능성이 매우 크다. 그러므로 어디서 오류를 던지고 받을 것인가 결정하는 것은 매우 중요하다. try 키워드로 던져진 오류를 받을 수 있다. try 키워드는 try 또는 try?, try! 등으로 표현할 수 있다.

함수, 메서드, 이니셜라이저의 매개변수 뒤에 throws 키워드를 사용하면 해당 함수, 메서드, 이니셜라이저는 오류를 던질 수 있다. 일반적으로 func cannotThrowErrors() -> String 처럼 표현하던 것에 func cannotThrowErrors() throws -> String 처럼 throws 키워드를 명시해주면 오류를 던질 수 있다. 이런 함수는 호출했을 때, 동작 도중 오류가 발생하면 자신을 호출한 코드에 오류를 던져서 오류를 알릴 수 있다.

**TIP**. throws는 함수나 메서드 자체에 타입에도 영향을 미친다. 즉, throws 함수나 메서드는 같은 이름의 throws가 명시되지 않는 함수나 메서드와 구분된다. 또, throws를 포함한 함수, 메서드, 이니셜라이저는 일반 함수, 메서드, 이니셜라이저로 재정의할 수 없다. 반대로 일반 함수, 메서드, 이니셜라이저는 throws 함수, 메서드, 이니셜라이저로 재정의할 수 있다.

```swift
enum VendingMachineError: Error {
    case invalidSelection
    case insfficientFunds(coinsNeeded: Int)
    case outOfStock
}

struct Item {
    var price: Int
    var count: Int
}

class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Biscuit": Item(price: 7, count: 11)
    ]

    var coinsDeposited = 0

    func dispense(snack: String) {
        print("\(snack) 제공")
    }

    func vend(itemNamed name: String) throws {
        guard let item = self.inventory[name] else {
            throw VendingMachineError.invalidSelection
        }

        guard item.count > 0 else {
            throw VendingMachineError.outOfStock
        }

        guard item.price <= self.coinsDeposited else {
            throw VendingMachineError.insfficientFunds(
                coinsNeeded: item.price - self.coinsDeposited)
        }

        self.coinsDeposited -= item.price

        var newItem = item
        newItem.count -= 1
        self.inventory[name] = newItem

        self.dispense(snack: name)
    }
}

let favoriteSnacks = [
    "yagom": "Chips",
    "jinsung": "Biscuit",
    "heejin": "Chocolate"
]

func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}

struct PurchaseSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}

let machine: VendingMachine = VendingMachine()
machine.coinsDeposited = 30

var purchase: PurchaseSnack = try PurchaseSnack(name: "Biscuit", vendingMachine: machine)
// Biscuit 제공

print(purchase.name)        // Biscuit

for (person, favoriteSnack) in favoriteSnacks {
    print(person, favoriteSnack)
    try buyFavoriteSnack(person: person, vendingMachine: machine)
}
// Biscuit 제공
// Biscuit
// yagom Chips
// Chips 제공
// jinsumg Biscuit
// heejin Chocolate

// 오류 발생!!
```

위의 자판기 VendingMachine 클래스는 오류를 던질 수 있는 vend(itemNamed:) 메서드가 있다. vend(itemNamed:) 메서드 내부에서는 오류가 발생했을 때 흐름을 제어하기 위해 guard를 통한 빠른 종료 구문을 사용한다. 특정 조건이 충족되지 않는담녀 throws 키워드를 통해 오류를 던져서 오류가 발생했다는 것을 자신을 호출한 코드에 알린다.

또한 vend(itemNamed:) 메서드가 오류를 던질 가능성이 있으므로, vend(itemNamed:) 메서드를 호출하는 함수 또한 오류를 던질 수 있어야 한다. 그래서 buyFavoriteSnack(person:vendingMachine:) 함수도 throws 키워드를 통해 오류를 던질 수 있는 함수로 구현해주어야 한다.

오류를 던질 수 있는 함수, 메서드, 이니셜라이저를 호출하는 코드는 반드시 오류를 처리할 수 있는 구문을 작성해주어야 한다. 그러나 위 코드에는 오류가 발생할 수 있는 메서드와 함수를 호출하면서도 try로 시도만 할 뿐 오류가 발생했을 때 처리할 수 있는 코드는 작성되어 있지 않는다. 위 코드는 for-in 구문 내에서 buyFavoriteSnack(person:vendingMachine:)함수 호출 중 오류가 발생한 후 적절한 처리를 해주지 않았기 때문에 다음 코드가 정상적으로 동작하지 않을 것이다.

이렇게 발생한 오류는 자신을 호출한 코드로 던져서 알릴 수는 있지만, 오류를 받은 코드가 적절히 오류를 처리해주지 않는다면 이후의 코드는 작동하지 않는다. 던져진 오류를 처리하는 방법에 대해 알아보겠다.
