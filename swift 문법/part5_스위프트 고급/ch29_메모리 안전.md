# 29. 메모리 안전

스위프트는 안전을 중요시하는 언어이다. 그래서 컴파일러가 코드에서 위험을 줄일수 있도록 많은 장치를 두었다. 그 중 큰 부분을 차지하는 것이 메모리의 안전한 접근이다. 변수를 사용하기 전에 초기화를 강제하고, 해제된 메모리에 접근할 수 없도록 설계된 것들이 그 대표적인 예라고 볼 수 있다.

스위프트는 메모리를 자동으로 관리하기 때문에 특별한 경우가 아니라면 프로그래머가 메모리의 접근에 대해 크게 신경쓸 필요가 없다. 그렇지만 메모리 접근 중 충돌이 발생할 수 있는 상황을 이해해두면 메모리가 충돌할 만한 코드를 작성하지 않는 능력자가 될 수 있지않을까? 그래도 걱정말자. 능력자가 아니라도 스위프트 컴파일러는 메모리 접근 충돌이 생길만한 코드를 미연에 알려준다.

## 29.1 메모리 접근 충돌의 이해

프로그래머가 변수에 값을 할당한다던가 함수의 전달인자로 변수의 값을 전달하는 등 다양한 경우에 코드를 통해 메모리에 접근하게 된다.

```swift
// one이 저장될 메모리 위치에 쓰기 접근
var one: Int = 1

// one이 저장된 메모리 위치에 읽기 접근
print("숫자 출력: \(one)")
```

메모리 접근 충돌은 서로 다른 코드에서 동시에 같은 위치의 메모리에 접근할 때 발생한다. 동시에 여러 접근을 하게 되면 예상치 못한 결과를 얻을 수 있다. 예를 들어 어떤 인스턴스 내부의 여러 프로퍼티의 값을 합산하여 반환하는 함수가 있을 때, 외부의 한 코드에서 인스턴스의 프로퍼티 값 일부를 수정하고, 동시에 또 다른 어딘가의 코드에서 합산하여 결과를 돌려주는 함수를 호출한다면 그 결과를 예측할 수 있을까? 동시에 일어나는 일이라면 수정 전의 합산 결과를 돌려줄지, 수정된 값의 합산 결과를 돌려줄지 누구도 장담할 수 없다. 이런 일이 발생하지 않을 것이라고 생각하지만 다중 스레드 프로그램에서는 흔히 겪을 수 있는 일이다. 우선 이 장에서는 다중 스레드 환경에서의 문제는 뒤로하고, 단일 스레드 프로그래밍 중에 발생할 수 있는 문제를 컴파일러가 미연에 방지해주는 것에 대한 내용을 다룬다.

### 29.1.1 메모리 접근의 특성

메모리 접근 충돌을 일으키는 메모리 접근에는 세 가지 특성이 있다. 다음 세 가지 조건에 모두 해당하는 메모리 접근이 두 군데 이상의 코드에서 동시에 일어나면 메모리 접근 충돌이 발생한다.

* 최소한 한 곳에서 쓰기 접근한다.
* 같은 메모리 위치에 접근한다.
* 접근 타이밍이 겹친다

순차적으로 코드를 실행하고, 메모리에 접근하는 것이 **순간적** 이라면 다른 코드에서 같은 메모리 위치에 동시에 접근할 일이 없다. 단일 스레드 환경에서는 대부분의 메모리 접근이 순간적 접근이고 동시에 다른 코드에서 접근할 일이 없다.

```swift
func oneMore(than number: Int) -> Int {
    return number + 1
}

var myNumber: Int = 1
myNumber = oneMore(than: myNumber)
print(myNumber)
// 2
```

반면에 **장기적 메모리 접근** 이라는 접근 방식도 있다. 장기적 메모리 접근 중에는 해당 메모리 접근이 끝나기 전에 다른 코드에서 메모리에 접근할 가능성이 있다. 접근 타이밍이 겹치게 되는 것이다.

접근 타이밍이 겹치게 되는 대표적 상황은 함수나 메서드에서 inout을 사용한 입출력 매개변수를 사용하는 경우나 구조체에서 mutating 키워드를 사용하는 가변 메서드를 사용하는 경우이다. 메모리의 같은 위치에 접근하는 여러 접근 타이밍이 겹친다고해서 무조건적으로 메모리 접근 충돌이 발생하는 것은 아니다. 그렇지만 접근 타이밍이 겹치는 경우 대개 메모리 접근 충돌이 발생할 가능성이 크다. 메모리 접근 충돌을 코드에서 정적으로 예측할 수 있는 경우 컴파일러에서 오류로 취급하여 컴파일하지 않는다.

접근 타이밍이 겹칠 때 발생하는 문제에 대해 이어서 설명하도록 하고, 문제가 발생하지 않는 상세한 조건은 마지막에 설명한다.

**TIP** 특정 변수나 상수의 메모리 주소를 알고 싶다면 다음 예제 코드를 참고하자. 해당 변수의 메모리 주소가 다른 변수의 메모리 주소와 같다면 두 변수는 서로 같은 메모리 위치를 참조하게 된다는 뜻이다.

```swift
// 값 타입의 경우
var number: Int = 100
print(Unmanaged<AnyObject>.fromOpaque(&number).toOpaque())

// 참조 타입의 경우
var object: SomeClass = SomeClass()
print(Unmanaged<AnyObject>.passUnretained(object).toOpaque())
```

## 29.2 입출력 매개변수에서의 메모리 접근 충돌

입출력 매개변수를 갖는 함수는 동작 중 모두 장기적 메모리 접근을 한다. 즉, 함수의 실행과 동시에 입출력 매개변수의 쓰기 접근이 시작되고 함수가 종료될 때까지 쓰기 접근을 유지한다. 함수가 종료될 때 쓰기 접근을 종료한다.

입출력 매개변수를 통한 장기적 메모리 접근 중에는 매개변수로 전달하는 변수는 다른 접근이 제한된다.

```swift
var step: Int = 1

func increment(_ number: inout Int) {
    number += step
}

increment(&step)    // 오류 발생!
```

위 코드의 step 변수는 increment(_:) 함수의 입출력 매개변수로 전달되었는데 함수 내부에서 같은 메모리 공간에 읽기 접근을 하려고 시도하기 때문에 메모리 접근 충돌이 발생한다. 그래서 위 코드를 실행하면 런타임 오류가 발생한다. 이런 경우 다음 코드처럼 새로운 변수를 생성해서 해결할 수 있다.

```swift
var step: Int = 1
var copyOfStep: Int = step

func increment(_ number: inout Int) {
    number += copyOfStep
}

increment(&step)
```

입출력 매개변수에서 메모리 접근 충돌이 발생할 수 있는 다른 예를 들자면 두 개 이상의 입출력 매개변수로 같은 변수를 전달하는 상황을 들 수 있다.

```swift
func balance(_ x: inout Int, _ y: inout Int) {
    let sum = x + y
    x = sum / 2
    y = sum - x
}

var playerOneScore: Int = 42
var playerTwoScore: Int = 30
balance(&playerOneScore, &playerTwoScore)   // 문제 없음
balance(&playerOneScore, &playerOneScore)   // 오류 발생!!
```

위 코드에서 첫 번째 함수 호출의 경우 각각 다른 변수를 입출력 매개변수로 전달하여 문제가 없지만, 두 번째 호출의 경우 같은 변수를 동시에 두 개의 입출력 매개변수로 전달하여 메모리 접근 충돌이 발생한다. 왜냐하면 playerOneScore라는 변수의 메모리 위치를 함수가 실행되는 동안 동시에 장기적 접근을 시도하기 때문에 문제가 발생한다. 이 경우에는 컴파일러에서 미리 컴파일 오류로 알려준다.

## 29.3 메서드 내부에서 self 접근의 충돌

구조체의 가변 메서드는 메서드 실행 중에 self에 쓰기 접근을 한다. 게임 캐릭터를 구조체로 구현했다고 생각했을 때, 캐릭터가 상처를 입으면 체력이 닳는다. 체력을 다시 회복하는 메서드와 체력을 다른 캐릭터와 공유하는 메서드를 만들고 그것을 다음 코드처럼 표현해보았다.

```swift
struct GamePlayer {
    var name: String
    var health: Int
    var energy: Int
    
    static let maxHealth = 10
    
    mutating func restoreHealth() {
        self.health = GamePlayer.maxHealth
    }
    
    mutating func shareHealth(with teammate: inout GamePlayer) {
        balance(&teammate.health, &health)
    }
}
```

위 코드의 restoreHealth() 메서드는 실행 중 인스턴스 자신인 self에 장기적으로 쓰기 접근을 한다. 현재 restoreHealth() 메서드는 내부의 코드 중 인스턴스의 다른 프로퍼티를 동시에 접근하는 코드가 없다. 반면에 shareHealth(with:) 메서드는 다른 캐릭터의 인스턴스를 입출력 매개변수로 받기 떄문에 메모리 접근 충돌이 발생할 여지가 있다.

```swift
var oscar: GamePlayer = GamePlayer(name: "Oscar", health: 10, energy: 10)
var maria: GamePlayer = GamePlayer(name: "Maria", health: 5, energy: 10)
oscar.shareHealth(with: &maria)
```

위 코드에서 shareHealth(with:) 메서드의 호출은 메모리 접근 충돌을 일으키지 않는다. teammate 입출력 매개변수로 전달된 maria는 shareHealth(with:) 메서드가 실행되는 중에 쓰기 접근을 하고, 가변 메서드를 실행해야 하는 oscar도 쓰기 접근을 한다. 하지만 서로 다른 메모리 위치에 있기 때문에 메모리 접근 충돌이 발생하지 안흔 것이다.

```swift
oscar.shareHealth(with: &oscar) // 오류 발생!
```

그렇지만 위 코드에서는 teamate 입출력 매개변수로 전달받은 메모리 위치와 oscar 인스턴스의 메모리 위치는 같은 곳이기 때문에 동시에 쓰기 접근을 하면 메모리 접근 충돌이 발생한다.

