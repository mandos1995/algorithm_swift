# 15. 맵, 필터, 리듀스
스위프트는 함수를 일급 객체로 취급한다. 따라서 함수를 다른 함수의 전달인자로 사용할 수 있다. 매개변수로 함수를 갖는 함수를 고차함수라고 부르는데, 스위프트에 유용한 대표적인 고차함수로는 맵, 필터, 리듀스 등이 있다. 이번 장에서는 맵, 필터, 리듀스를 통해 데이터의 연산을 쉽게 실행하는 방법을 알아보자.

## 15.1 맵
**맵**은 자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수이다. 스위프트에서 맵은 배열, 딕셔너리, 세트, 옵셔널 등에서 사용할 수 있다. 조금 더 정확히 말하자면 스위프트의 Sequence, Collection 프로토콜을 따르는 타입과 옵셔널은 모두 맵을 사용할 수 있다.

맵을 사용하면 컨테이너가 담고 있던 각각의 값을 매개변수를 통해 함수에 적용한 후 다시 컨테이너에 포장하여 반환한다. 기존 컨테이너의 값은 변경되지 않고 새로운 컨테이너가 생성되어 반환된다. 그래서 **맵은 기존 데이터를 변형**하는 데 많이 사용한다.

```swift
container.map(f(x)) // 컨테이너의 map 메서드 호출
    return f(container의 각 요소) // 새로운 컨테이너
```
map 메서드의 사용법은 앞서 알아본 for-in 구문과 별반 차이가 없다. 다만 코드의 재사용 측면이나 컴파일러 최적화 측면에서 본다면 성능 차이가 있다. 또, 다중 스레드 환경일 때 대상 컨테이너의 값이 스레드에서 변경되는 시점에 다른 스레드에서 동시에 값이 변경되려고 할 때 예측치 못한 결과가 발생하는 부작용을 방지할 수도 있다. 다음 코드를 통해 for-in 구문과 map 메서드 사용을 비교해보겠다.

```swift
let numbers: [Int] = [0, 1, 2, 3, 4]

var doubledNumbers: [Int] = [Int]()
var strings: [String] = [String]()

// for 구문 사용
for number in numbers {
    doubledNumbers.append(number * 2)
    strings.append("\(number)")
}

print(doubledNumbers)   // [0, 2, 4, 6, 8]
print(strings)          // ["0", "1", "2", "3", "4"]

// map 메서드 사용
doubledNumbers = numbers.map({ (number: Int) -> Int in
    return number * 2
})
strings = numbers.map({ (number: Int) -> String in
    return "\(number)"
})

print(doubledNumbers)   // [0, 2, 4, 6, 8]
print(strings)          // ["0", "1", "2", "3", "4"]
```

짧은 코드라 차이를 느끼기는 힘들곘지만, 위의 코드를 살펴보면 map 메서드를 사용했을 때 for-in 구문을 사용한 것보다 간결하고 편리하게 각 요소의 연산을 실행하는 것을 볼 수 있다. 심지어 map 메서드를 사용하면 for-in 구문을 사용하기 위하여 빈 배열을 처음 생성해주는 작업도 필요가 없다. 배열의 append 연산을 실행하기 위한 시간도 필요 없다.

map 메서드를 사용하여 코드가 조금 더 간략해지긴 했지만, 우리가 배웠던 클로저 표현식을 사용하여 표현을 더 간략화할 수 있다.

```swift
let numbers: [Int] = [0, 1, 2, 3, 4]

var doubledNumbers: [Int] = [Int]()

doubledNumbers = numbers.map({ (number: Int) -> Int in
    return number * 2
})

// 매개변수 및 반환 타입 생략
doubledNumbers = numbers.map({ return $0 * 2 })
print(doubledNumbers)   // [0, 2, 4, 6, 8]

// 반환 키워드 생략
doubledNumbers = numbers.map({ $0 * 2 })
print(doubledNumbers)   // [0, 2, 4, 6, 8]

// 후행 클로저 사용
doubledNumbers = numbers.map { $0 * 2 }
print(doubledNumbers)   // [0, 2, 4, 6, 8]
```
클로저 표현을 간략화하니 조금씩 코드가 더 간결해졌다. 그런데 처음에 언급했던 코드의 재사용 측면에 대해 생각해볼 필요가 있다. 같은 기능을 여러 번 사용할 것이라면 하나의 클로저를 여러 map 메서드에 사용하는 편이 좋을 것 같아보인다. 다음 코드를 통해 재사용 가능한 코드로 재구성해보았다.
```swift
let evenNumbers: [Int] = [0, 2, 4, 6, 8]
let oddNumbers: [Int] = [0, 1, 3, 7, 9]
let multiplyTwo: (Int) -> Int = { $0 * 2 }

let doubledEvenNumbers = evenNumbers.map(multiplyTwo)
print(doubledEvenNumbers)   // [0, 4, 8, 12, 16]

let doubledOddNumbers = oddNumbers.map(multiplyTwo)
print(doubledOddNumbers)    // [0, 2, 6, 14, 18]
```
map 메서드는 배열에서만 사용할 수 있는 것은 아니다. 여러 컨테이너 타입에 모두 적용이 가능하다. 다음 코드는 다양한 종류의 컨테이너에서 map 메서드를 실행해본 결과이다.

```swift
let alphabetDictionary: [String: String] = ["a":"A", "b":"B"]

var keys: [String] = alphabetDictionary.map { (tuple: (String, String)) -> String in
    return tuple.0
}

keys = alphabetDictionary.map { $0.0 }

let values: [String] = alphabetDictionary.map { $0.1 }
print(keys)     // "b", "a"
print(values)   // "A", "B"


var numberSet: Set<Int> = [1, 2, 3, 4, 5]
let resultSet = numberSet.map { $0 * 2 }
print(resultSet)        // [2, 4, 6, 8, 10]


let optionalInt: Int? = 3
let resultInt: Int? = optionalInt.map { $0 * 2 }
print(resultInt)        // 6


let range: CountableClosedRange = (0...3)
let resultRange: [Int] = range.map { $0 * 2 }
print(resultRange)      // [0, 2, 4, 6]
```
이렇게 map 메서드를 사용하여 여러 자료를 손쉽게 연산할 수 있다.

## 15.2 필터
**필터**는 말 그대로 **컨테이너 내부의 값을 걸러서 추출**하는 역할을 하는 고차함수이다. 맵과 마찬가지로 새로운 컨테이너에 값을 담아 반환해준다. 다만 맵처럼 기존 콘텐츠를 변형하는 것이 아니라, 특정 조건에 맞게 걸러내는 역할을 할 수 있다는 점이 다르다.

filter 함수의 매개변수로 전달되는 함수의 반환 타입은 Bool이다. 해당 콘텐츠의 값을 갖고 새로운 컨테이너에 포함될 항목이라고 판단하면 true를 포함하지 않으려면 false를 반환해주면 된다.

다음 코드를 통해 간단한 필터 메서드의 사용을 살펴보자.

```swift
let numbers: [Int] = [0, 1, 2, 3, 4, 5]

let evenNumbers: [Int] = numbers.filter { (number: Int) -> Bool in
    return number % 2 == 0
}
print(evenNumbers)      // [0, 2, 4]

let oddNumber: [Int] = numbers.filter { $0 % 2 == 1 }
print(oddNumber)        // [1, 3, 5]
```
만약 콘텐츠의 변형 후에 필터링하고 싶다면 다음 코드처럼 맵을 사용한 후에 필터 메서드를 호출하면 된다.

```swift
let numbers: [Int] = [0, 1, 2, 3, 4, 5]

let mappedNumbers: [Int] = numbers.map { $0 + 3 }

let evenNumbers: [Int] = mappedNumbers.filter { (number: Int) -> Bool in
    return number % 2 == 0
}
print(evenNumbers)      // [4, 6, 8]

// mappedNumbers를 굳이 여러 번 사용할 필요가 없다면 메서드를 체인처럼 연결하여 사용할 수 있다.
let oddNumber: [Int] = numbers.map { $0 + 3 }.filter { $0 % 2 == 1 }
print(oddNumber)        // [3, 5, 7]
```
위의 코드처럼 맵과 필터를 연결하여 사용하면 복잡한 연산도 손쉽게 실행할 수 있다.
