# 13.클로저
스위프트에서 함수형 프로그래밍 패러다임을 접할 때 첫걸음으로 꼭 알아야 할 녀석이 바로 **클로저**이다. 클로저를 잘 이해해야 스위프트의 함수형 프로그래밍 패러다임 스타일을 좀 더 명확하게 이해할 수 있다. 클로저와 제네릭, 프로토콜, 모나드 등이 결합해서 스위프트는 훨씬 강력한 언어가 되었다.

스위프트의 클로저는 C 언어나 Objective-C의 블록 또는 다른 프로그래밍 언어의 람다와 유사하다. 클로저는 일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것을 말한다. 뭔가 함수랑 비슷하다고 생각하는가? 사실 함수는 클로저의 한 형태이다.

클로저는 변수나 상수가 선언된 위치에서 참조를 획득하고 저장할 수 있다. 이를 변수나 상수의 클로징(잠금)이라고 하며 클로저는 여기서 착안된 이름이다. 획득때문에 메모리 부담이 가지 않을까 걱정할 수도 있지만, 앞서 설명했듯이 스위프트는 스스로 메모리를 관리한다.

클로저의 몇 가지 모양 중 하나가 함수이다. 함수는 이미 앞에서 배웠는데 여기서는 함수가 클로저의 몇 가지 모습 중 하나에 속한다는 것을 확인해볼 수 있다.

클로저는 세 가지 형태가 있다.
* 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
* 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
* 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

애플은 클로저의 문법이 정갈하고 깔끔한 스타일이라고 주장하지만, 클로저 문법에 난색을 표하는 분도 있을 것이다. 물론 클로저의 문법에 난색을 표헀다 해서 클로저 자체의 기능이 별로이거나 불필요하다라는 뜻은 아니다. 오히려 클로저를 빼놓고는 스위프트를 논할 수 없을 만큼 중요한 내용이다.

먼저 클로저 문법을 살펴보기 전에 클로저를 얼마나 다양하게 표현할 수 있는지 잠깐 살펴보겠다.
* 클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략 할 수 있다.
* 클로저에 단 한줄의 표현만 들어있다면 암시적으로 이를 반환 값으로 취급한다.
* 축약된 전달인자 이름을 사용할 수 있다.
* 후행 클로저 문법을 사용할 수 있다.

이제부터 클로저의 문법을 살펴보겠다. 중첩 함수(7.3절)는 함수 안에 포함된 하나의 클로저 형식이었다. 그런데 이렇게 함수를 중첩하여 사용하기보다는 조금 더 간단한 형태로 함수처럼 사용하고 싶을 수 있고 또는 함수 내부에서 다른 함수를 사용할 때 내부 함수에 이름을 붙일 필요가 없을 수 있다. 이런 여러 가지 경우에 함수 또는 메서드의 전달인자로 함수를 받아오면 된다.

클로저 표현 방법은 클로저가 함수의 모습이 아닌 하나의 블록의 모습으로 표현될 수 있는 방법을 의미한다. 클로저 표현 방법은 클로저의 위치를 기준으로 크게 기본 클로저 표현과 후행 클로저 표현이 있다. 또, 각표현 내에서 가독성을 해치지 않는 선에서 표현을 생략하거나 축약할 수 있는 방법이 있다. 우선 두 클로저 표현 방법(기본 클로저 및 후행 클로저)을 먼저 살펴본 후, 문맥을 이용한 타입 유추부터 표현을 생략하거나 축약할 수 있는 방법에 대해 알아보자.

## 13.1 기본 클로저
기본 클로저 내용을 포함하여 앞으로 sorted(by:) 메서드를 이용해 동일한 기능을 하는 코드를 어떻게 간결하게 표현하는지 알아보겠다.

스위프트 표준 라이브러리에는 배열의 값을 정렬하기 위해 구현한 sorted(by:) 메서드가 있다. 이 메서드는 클로저를 통해 어떻게 정렬할 것인가에 대한 정보를 받아 처리하고 결괏값을 배열로 돌려준다. 단순히 정렬만 하기 때문에 입력받은 배열의 타입과 크기가 동일하다. 기존의 배열은 변경하지 않고 정렬된 배열을 새로 생성하여 반환해준다.

다음은 sorted(by:) 메서드의 정의이다. 모르는 키워드나 기능이 있더라도 지금 모두 이해할 필요는 없다.

```swift
public func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) ->
    [Element]
```

String 타입 배열에 이름을 넣어 영문 알파벳을 내림차순으로 정렬하려고 한다. 다음 코드에서 먼저 이름 배열을 하나 생성한다.

```swift
let names: [String] = ["wizplan", "eric", "yagom", "jenny"]
```

sorted(by:) 메서드는 (배열의 타입과 같은 두 개의 매개변수를 가지며 Bool 타입을 반환 하는) 클로저를 전달인자로 받을 수 있다. 반환하는 Bool 값은 첫 번쨰 전달인자 값이 새로 생성되는 배열에서 두 번째 전달인자 값보다 먼저 배치되어야 하는지에 대한 결괏값이다. true를 반환하면 첫 번째 전달인자가 두 번째 전달인자보다 앞에 온다.

**Tip 전달인자로 함수를 보낸다?**

함수를 메서드의 전달인자로 보내는 일은 함수형 프로그래밍 패러다임에서는 아주 당연한 일이다. 아직 함수형 패러다임이 익숙하지 않은 분들은 이번 파트를 읽으면서 천천히 익혀보길 바란다. 우선 클로저의 문법을 익힌다는 생각으로 먼저 훑어보고 나중에 차츰차츰 되돌아보면 더욱 수월하게 이해할 수 있을 것이다.

우선은 우리가 기존에 익숙한 방법대로 매개변수로 String 타입 두 개를 가지며, Bool 타입을 반환하는 함수를 구현해보자. 구현된 함수를 sorted(by:) 메서드의 전달인자로 전달하여 reversed라는 이름의 배열로 반환받는다. 앞서 설명했듯이 전달받는 두 전달인자는 정렬에 참고할 값이고, 반환될 값은 첫 번쨰 전달인자가 앞으로 배치될지 뒤로 배치될디에 대한 Bool 타입 값이다. 함수는 클로저의 한 형태이다.

```swift
let names: [String] = ["wizplan", "eric", "yagom", "jenny"]

func backwards(first: String, second: String) -> Bool {
    print("\(first) \(second) 비교중")
    return first > second
}

let reversed: [String] = names.sorted(by: backwards)
print(reversed)     // ["yagom", "wizplan", "jenny", "eric"]
```

만약 first 문자열이 second 문자열보다 크다면(알파벳이 더 뒤쪽) backwards(first:second:) 함수의 반환 값은 true가 될 것이다. 즉, 값이 더 큰 first 문자열이 second 문자열보다 앞쪽에 정렬되어야 한다는 뜻이다. 그러나 first > second 라는 반환 값을 받기 위해 너무 많은 표현을 사용했다. 예시 코드에서 print( ) 함수는 참고용 콘솔 출력이니 제외해도 역시 많다. 함수 이름부터 매개변수 표현까지 부가적인 표현도 많다. 이를 클로저 표현을 사용해서 조금 더 간결하게 표현하겠다.

클로저 표현은 통상 아래 형식을 따른다.

```swift
{ (매개변수들) -> 반환타입 in
    실행코드  
}
```

클로저도 함수와 마찬가지로 입출력 매개변수를 사용할 수 있다. 매개변수 이름을 지정한다면 가변 매개변수 또한 사용 가능하다. 다만 클로저는 매개변수 기본값을 사용할 수 없다.

이제 backwards(first: second:) 함수를 클로저 표현으로 대체해보겠다.

```swift
let names: [String] = ["wizplan", "eric", "yagom", "jenny"]

// backwards(first:second:) 함수 대신에 sorted(by:) 메서드의 전달인자로 클로저를 직접 전달한다.
let reversed: [String] = names.sorted(by: {(first: String, second: String) -> Bool in
    return first > second
})
print(reversed)     // ["yagom", "wizplan", "jenny", "eric"]
```

sorted(by:) 메서드로 전달하는 클로저의 매개변수 개수와 타입, 그리고 반환 타입이 모두 backwards(first:second:) 함수와 같다. 아직 익숙하지 않겠지만 처음보다 코드가 훨씬 간결해지고 직관적으로 바꼈다.

이렇게 프로그래밍하면 sorted(by:) 메서드로 전달되는 backwards(first:second:) 함수가 어디에 있는지, 어떻게 구현되어 있는지 찾아다니지 않아도 된다. 물론, 반복해서 같은 기능을 사용하려면 함수로 구현해두는 것도 나쁘지않다. 이것은 선택이다. 
