# 22.제네릭

제네릭은 스위프트의 강력한 기능 중 하나이다. 제네릭을 이용해 코드를 구현하면 어떤 타입에도 유연하게 대응할 수 있따. 또한 제네릭으로 구현한 기능과 타입은 재사용하기도 쉽고, 코드의 중복을 줄일 수 있기에 깔끔하고 추상적인 표현이 가능하다.

스위프트 표준 라이브러리 또한 수많은 제네릭 코드로 구성되어 있다. 사실 우리는 지금까지 제네릭 기능을 수없이 사용하고 있었다. 예를 들어 Array, Dictionary, Set 등의 타입은 모두 제네릭 컬렉션이다. Int나 String 타입을 요소로 갖는 배열을 만들거나 그 외에 어떤 타입도 배열을 요소로 가질 수 있었던 것은 모두 제네릭 덕분이다. 딕셔너리도, 세트도 마찬가지이다.

```swift
public struct Array<Element> : RandomAccessCollection, MutableCollection {
    public typealias Index = Int
    public typealias Iterator = IndexingIterator<[Element]>
    // 중략 ...
    public var startIndex: Int { get }
    public var endIndex: Int { get }
    // 중략 ...
    public subscript(index: Int) -> Element
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
    // 중략 ...
    public mutating func popLast() -> Element?
    // 중략 ...
    public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]
    // 중략 ...
    public var last: Element? { get }
    // 중략 ...
    public func reduce<Result>(_ initialResult: Result,
                               _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result
}
```

제네릭을 사용하고자 할 때는 제네릭이 필요한 타입 또는 메서드의 이름 뒤의 홀화살괄호 기호(<>) 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시한다.

```swift
제네릭을 사용하고자 하는 타입 이름 <타입 매개변수>
제네릭을 사용하고자 하는 함수 이름 <타입 매개변수> (함수의 매개변수...)
```

위의 코드의 Array는 타입 매개변수 Element가 있으며, map 메서드는 타입 매개변수 T 가 있다. Array는 제네릭을 사용하는 제네릭 타입이고, map 메서드는 제네릭을 사용하는 제네릭 함수이기 때문이다.

앞서 5장 연산자 파트에서 구현했던 예제 코드를 살펴보며 본격적으로 제네릭을 이해해보자. 사용자 정의 연산자와 관련된 코드를 다시 살펴보자.

```swift
prefix operator **

prefix func ** (value: Int) -> Int {
    return value * value
}

let minusFive: Int = -5
let sqrtMinusFive: Int = **minusFive

print(sqrtMinusFive)  // 25
```

위 코드의 사용자 정의 연산자 **는 조금 한정된 범위에서만 사용할 수 있다. 즉, Int 타입에서만 사용자 정의 연산자를 사용할 수 있다. UInt 타입, 즉 부호가 없는 정수 타입에서는 Int 타입에 구현해준 사용자 정의 연산자를 사용하지 못한다. 그래서 우리는 조금 더 범용적으로 사용하기 위하여 '정수의 제곱을 구하는 연산자'를 구현하려고 한다. 프로토콜과 제네릭이라는 스위프트의 훌륭한 기능을 조합하여 정수 타입 프로토콜, 즉 BinaryInteger 프로토콜에 해당하는 값이면 해당 연산자를 사용할 수 있도록 (제네릭을 이용하여) 구현해줄 수 있다. 그렇게 되면 UInt 타입에서도 해당 연산자를 사용할 수 있다.

```swift
prefix operator **

prefix func **<T: BinaryInteger> (value: T) -> T {
    return value * value
}
let minusFive: Int = -5
let five: UInt = 5

let sqrtMinusFive: Int = **minusFive
let sqrtFive: UInt = **five

print(sqrtMinusFive)  // 25
print(sqrtFive)       // 25
```

아직 제네릭 문법이 눈에 들어오지 않아 감이 잘 오지 않을 것이다. 제네릭 문법과 제네릭 설명을 살펴본 후 다시 생각해보자.

조금 더 쉬운 예를 통해 제네릭을 차근차근 이해해보자. Int 타입의 두 변숫값을 교환하는 swapTwoInts(_ : _ : ) 함수를 바꿔볼 것이다. 어떻게 하면 코드의 중복을 줄이고 타입에 유연하게 구현할 수 있는지 제네릭 코드를 사용하여 차근차근 살펴보겠다.

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA: Int = a
    a = b
    b = temporaryA
}

var numberOne: Int = 5
var numberTwo: Int = 10

swapTwoInts(&numberOne, &numberTwo)
print("\(numberOne), \(numberTwo)")     // 10, 5
```

위의 swapTwoInts(_ : _ : ) 함수는 두 Int 타입의 변숫값을 교환하는 역할을 충분히 해낼 수 있다. 그렇지만 만약에 Int 타입이 아닌 Double이나 String 타입의 변숫값을 서로 교환하고 싶다면? 별도의 함수를 다시 구현해주어야 할 것이다.

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA: String = a
    a = b
    b = temporaryA
}

var stringOne: String = "A"
var stringTwo: String = "B"

swapTwoStrings(&stringOne, &stringTwo)

print("\(stringOne), \(stringTwo)")     // B, A
```

위의 코드의 swapTwoStrings(_ : _ : ) 함수는 두 String 타입의 변수끼리 값을 교환하는 역할은 충분히 해냈지만 이 함수도 마찬가지로 String 타입끼리의 교환만 허용할 뿐이다. Double 타입의 값 교호나을 원한다면 또 다른 함수를 구현해야 한다. 그리고 타입마다 다른 함수를 써줘야 하는 불편함도 있다.

그러면 여기서 의문을 하나 새길 수 있다. 그럼 Any를 사용하면 되지 않을까? 한번 구현하여 사용해보자.

```swift
func swapTwoValues(_ a: inout Any, _ b: inout Any) {
    let temporayA: Any = a
    a = b
    b = temporayA
}

var anyOne: Any = 1
var anyTwo: Any = "Two"

swapTwoValues(&anyOne, &anyTwo)
print("\(anyOne), \(anyTwo)")           // Two, 1

anyOne = stringOne
anyTwo = stringTwo

swapTwoValues(&anyOne, &anyTwo)
print("\(anyOne), \(anyTwo)")           // "A", "B"
print("\(stringOne), \(stringTwo)")     // "B", "A"

swapTwoValues(&stringOne, &stringTwo)   // 오류 - Any 외 다른 타입의 전달인자 전달 불가
```

위의 swapTwoValues(_ : _ : ) 함수는 inout 매개변수로 두 Any 타입의 값을 받는다. Any 타입의 anyOne과 anyTwo 변수의 값을 교환하는 데는 무리가 없다. 다만 우리는 Any 타입의 두 변수에 어떤 타입의 값이 들어있을지 모른다. Int면 Int끼리, String이면 String끼리 교환하고 싶은데, 그런 제한을 줄 수 없는 것이다.

또 다른 문제점도 있다. Any 타입의 inout 매개변수를 통해 전달될 전달인자의 타입은 Any로 전달되어야 한다. 다른 타입인 String 타입의 변수 (stringOne, stringTwo)를 전달인자로 전달할 수가 없다. 그래서 String 타입의 값을 Any 타입의 변수 (anyOne, anyTwo)에 넣어 함수를 호출해야 하는데, 그 순간 값은 복사되어 할당한다. 즉, 새로운 변수로만 함수를 호출할 수 있는 것이다. 그렇게 되면 우리가 원했던 stringOne과 stringTwo의 값은 교환할 수 없다.

## 21.1 제네릭 함수

위의 코드는 제네릭을 사용하지 않은 함수인데 이 함수들의 한계점을 제네릭 함수를 통해 말끔히 해결할 수 있다. 즉, 같은 타입인 두 변수의 값을 교환한다는 목적을 타입에 상관없이 할 수 있도록 단 하나의 함수로 구현할 수 있다.

**NOTE_swap함수**

스위프트 표준 라이브러리에는 위의 swap~ 와 같은 기능을 실행하는 더 안전한 함수인 swap(_ : _ : )이 따로 구현되어 있다. 이 함수의 정의는 다음과 같다.

`public func swap<T>(_ a: inout T, _ b: inout T)`

이 함수를 사용하는 것이 따로 값 교환 함수를 구현하여 사용하는 것보다 안전하므로 표준 함수를 사용하는 쪽을 권장한다.

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA: T = a
    a = b
    b = temporaryA
}
var numberOne: Int = 5
var numberTwo: Int = 10

swapTwoValues(&numberOne, &numberTwo)
print("\(numberOne), \(numberTwo)")     // 10, 5

var stringOne: String = "A"
var stringTwo: String = "B"

swapTwoValues(&stringOne, &stringTwo)
print("\(stringOne), \(stringTwo)")     // B, A

var anyOne: Any = 1
var anyTwo: Any = "Two"

swapTwoValues(&anyOne, &anyTwo)
print("\(anyOne), \(anyTwo)")           // Two, 1

swapTwoValues(&numberOne, &stringOne)   // 오류!! - 같은 타입끼리만 교환 가능
```

위의 swapTwoValues(_ : _ : ) 함수는 제네릭을 사용하여 구현한 함수이다. 함수 내부의 모습은 swapTwoInts(_ : _ : ), swapTwoStrings(_ : _ : ) 함수 등과 특별히 다를게 없다. 그러나 함수의 이름 뒤에 뭔가 추가된 모양새가 있음을 확인할 수 있다. 또, 매개변수의 데이터 타입도 처음보는 T라는 알파벳 하나만 덜렁 있는 것을 볼 수 있다.

제네릭 함수는 실제 타입 이름(Int, String 등)을 써주는 대신에 플레이스홀더(위 함수에서는 T)를 사용한다. 플레이스홀더는 타입의 종류를 알려주지 않지만 말 그대로 어떤 타입이라는 것은 알려준다. 즉, 매개변수로 플레이스홀더 타입이 T인 두 매개변수가 있으므로, 두 매개변수는 같은 타입이라는 정도는 알 수 있다. T의 실제 타입은 함수가 호출되는 그 순간 결정된다. Int 타입의 변수가 전달인자로 전달되었다면 T는 Int가 되고, String 타입의 변수가 전달인자로 전달되었다면 그 호출 순간에는 T는 String이 된다.

제네릭 함수의 플레이스홀더를 지정하는 방법은 함수 이름 오른쪽의 홀화살괄호 기호 (<>)안쪽에 플레이스 홀더 이름들을 나열하는 것이다. 예를 들어 func swapTwoValues<T> 에서는 T가 이 함수의 플레이스홀더로 사용된다는 것을 뜻한다. T가 플레이스홀더로 사용되기 때문에 스위프트 컴파일러는 함수의 문법을 검사할 때, T의 실제 타입을 신경쓰지 않는다.

플레이스홀더 타입 T는 타입 매개변수의 한 예로 들 수 있다. 타입 매개변수는 플레이스홀더 타입의 이름을 지정하고 명시하는 역할을 하며, 함수의 이름 뒤 홀화살기호 (<>) 안쪽에 위치한다.

타입 매개변수를 지정해주면 이를 함수의 매개변수 타입으로 사용할 수 있다. 또는 함수의 반환 타입으로 사용할 수도 있으며, 함수 내부 변수의 타입 지정을 위해 사용할 수도 있다. 각각의 경우 타입 매개변수는 함수를 호출할 때마다 실제 타입으로 치환된다. 즉, Int 타입 변수 두 개를 통해 swapTwoValues(_ : _ : ) 함수를 호출한다면 T는 Int로 치환되고, String 타입 변수 두 개를 통해 swapTwoValues(_ : _ : ) 함수를 호출한다면 T는 String으로 치환된다. 호출할 때마다 다른 타입으로 작동한다는 뜻이다. swapTwoValues(_ : _ : ) 함수처럼 하나의 타입 매개변수를 갖지 않고 여러 개의 타입 매개변수를 갖고 싶다면 홀화살괄호 기호 안쪽에 쉼표로 분리한 여러 개의 타입 매개변수를 지정해줄 수 있다. <T, U, V> 처럼 말이다.

타입 매개변수 대부분은 의미있는 이름을 갖게 되는 경우가 많다. 예를 들어 딕셔너리에 쓰이는 Key, Value 같은 이름들이다. Dictionary<Key, Value>와 같이 표현했던 것 기억나는가? 그리고 배열에서 요소를 표현하기 위해 Array<Element>와 같이 표현했다. 이렇게 의미있는 이름으로 타입 매개변수의 이름을 지정해주면 제네릭 타입 및 제네릭 함수와 타입 매개변수와의 관계를 조금 더 명확히 표현해줄 수 있다. 그러나 특별히 관계의 의미를 이름으로 표현하기 어려울 때는 관용적으로 T, U, V등의 대문자 한 글자로 표현한다.

**TIP** 타입 매개변수 이름은 타입 이름이기도 하므로 대문자 카멜케이스를 사용하여 표현한다. T, Key, Value, Element, TypeParameterName과 같이 각 단어의 첫 글자를 대문자로 표현해준다.
