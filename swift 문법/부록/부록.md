# 부록

스위프트 사용 시 미리 알아두면 도움이 될 만한 내용을 부록으로 모았다.

스위프트에 관련된 더 자세하고 많은 사항은 스위프트 문서와 스위프트 블로그에서 확인할 수 있다. 기술 문서를 읽는 습관을 들이면 개발에 도움이 되리라 생각한다.

## A. 스위프트의 주요 프로토콜

스위프트 표준 라이브러리에 정의된 주요 프로토콜을 알아두면 스위프트의 기본 기능을 후러씬 편리하게 활용할 수 있을 것이다. 또, 각각의 프로토콜 정의를 살펴보면 더욱 유용할 것이다. 스위프트 문서를 참고하면 프로토콜 간의 상관관계 도한 쉽게 알아볼 수 있다.

|프로토콜 이름|설명|
|---|---|
|AnyObject|모든 클래스 타입이 암시적으로 준수하는 프로토콜|
|BinaryInteger|스위프트의 정수 타입을 위한 요구사항|
|CaseIterable|연관값이 없는 열거형인 경우에 CaseIterable 프로토콜을 준수하면 각각의 case를 순회할 수 있다. 순회할 case는 allCases 콜렉션으로 제공|
|Codable|Encodable과 Decodable의 합성 프로토콜이다. Codable 프로토콜을 준수하는 타입은 다른 표현방식으로 상호 변환할 수 있다. 대표적인 예로 스위프트의 인스턴스를 JSON 문자열로 변환하고, 반대로 JSON 문자열을 스위프트의 인스턴스로 상호 변환할 수 있는 기능을 제공한다.|
|CodingKey|인코딩과 디코딩의 키로 활용할 타입|
|Collection|요소에 인덱스와 서브스크립트로 접근할 수 있는 시퀀스|
|Comparable|관계 연산자(<,> 등등)을 사용해 비교할 수 있는 타입이다. 숫자나 문자열처럼 순서를 갖는 타입에 사용하기 적합핟. 스위프트 표준 라이브러리의 대부분의 타입은 Comparable 프로토콜을 준수한다.|
|CustomString Convertible|사용자 정의 텍스트 표현을 할 수 있는 타입이다. 사용자 정의 텍스트 표현은 print 등의 함수에서 사용하는 출력 스트림에 쓰일 수 있다.
|Equatable|== 및 != 연산자를 사용하여 값이 동일한지 판단할 수 있는 타입이다. 스위프트 표준 라이브러리에 정의된 타입 대부분은 Equatable 프로토콜을 준수한다. 사용자 정의 타입에서 Equatable 프로토콜을 채택하면 해당 타입을 위한 == 연산자를 구현해야 한다. 그러면 표준 라이브러리에서 != 연산자를 자동으로 구현해준다.
|Error|던질 수 있는 요류를 표현하는 타입이다. Error 프로토콜을 준수하는 타입은 스위프트의 오류처리 시스템의 오류를 표현한다. Error 프로토콜을 별다른 요구사항 정의가 없으므로 어떤 타입이든 채택하면 준수할 수 있다. 열거형 타입을 활용하여 오류를 표현하는 데 많이 사용한다.
|FixedWidthInteger|정수 오버플로 연산을 지원하기 위한 요구사항
|Hashable|정수 해시 값을 제공하고 Dictionay의 키가 될 수 있는 타입
|IteratorProtocol|시퀀스를 통한 반복을 위해 반복 상태와 인터페이스를 캡슐화함|
|Sequence|for-in 구문을 통해 반복될 수 있는 타입
|SignedInteger|스위프트의 부호가 있는 정수 타입을 위한 요구사항
|SignedNumeric|뺄셈 연산이 가능하며 음의 표현이 가능하고 0으로 초기화될 수 있는 타입
|TextOutputStreamable|텍스트 스트리밍 기능을 실행할 수 있는 타입이다. TextOutputStreamable 인스턴스는 어떤 출력 스트림이든 쓰일 수 있다. TextOutputStreamable 프로토콜을 준수하는 대표적인 타입으로 String, Character, UnicodeScalar 등이 있다.
|UnsignedInteger|스위프트의 부호가 없는 정수 타입을 위한 요구사항

### ExpressibleByLiteral

리터럴은 코드에 쓰인 값의 타입대로 그 타입의 인스턴스를 생성할 수 있도록 하는 표현이다. ExpressibleByLiteral 종류의 프로토콜은 말 그대로, 코드에 쓰이는 그대로 자신의 타입으로 인스턴스를 초기화하고 생성할 수 있는 타입의 프로토콜을 뜻한다.

예를 들어 ExpressibleByArrayLiteral 프로토콜을 준수한다면, 배열 리터럴로 자신의 인스턴스를 초기화할 수 있는 타입이 된다는 것을 뜻한다.

Set 타입은 ExpressibleByArrayLiteral 프로토콜을 준수한다. 그래서 let aSet: Set<Int> = [1, 2, 3] 처럼 표현할 수 있다.

|프토토콜 이름|설명|
|---|---|
|ExpressibleByArrayLiteral|배열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByBooleanLiteral|불리언 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByDictionaryLiteral|딕셔너리 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByFloatLiteral|부동소수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByIntegerLiteral|정수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByNilLiteral|nil 통해 초기화할 수 있는 타입|
|ExpressibleByStringLiteral|문자열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByUnicodeScalarLiteral|유니코드 스칼라 값을 갖는 하나의 문자를 갖는 문자열 리터럴을 통해 초기화할 수 있는 타입|

## B. 스위프트의 주요 함수

스위프트 표준 라이브러리에서 기본적으로 제공하는 함수에 대해 알아보자. 해당 함수들은 전역함수이므로 새로운 함수를 정의할 때 이름이 중복되지 않도록 주의를 기울이는 것이 좋다.

### abs

```swift
@inlinable public func abs<T>(_ x: T) -> T where T : Comparable, T : SignedNumeric
```

전달인자로 전달받은 값의 절대 값을 반환하는 함수

### assert

```swift
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String (), file: StaticString = #file, line: UInt = #line)
```

전통적인 C 스타일의 Assert를 위해 제공하는 함수이다. 실제 배포하는 빌드에서는 전혀 영향을 미치지 않으며 실제 배포하는 코드에는 precondtion 함수를 사용하는 것이 좋다.

* 플레이그라운드와 - Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 condition이 실행되지 않으며, 프로그램에 어떠한 영향도 미치지 않는다.
* -Ounchecked 빌드 구성에서는 condition이 실행되지 않지만 최적화 중 true를 반환할 것이라는 가정하에 빌드된다.

**NOTE_빌드구성**

-Onone, -O, -Ounchecked 구성은 사실 디버그, 배포, 미확인배포 등을 위한 빌드 구성이 아니라 스위프트 최적화 단계 옵션 구성이다. Xcode에서 각각 디버그, 배포, 미확인배포 등에 기본적으로 적용되는 구성이다.

### assertionFailure

```swift
@inlinable public func assertionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line)
```

배포 버전 빌드에는 영향을 미치지 않지만, 디버그용 빌드에서 프로그램을 중단하고 디버그 가능한 상태로 전환하고 싶을 때 사용한다.

* 플레이그라운드와 -Onone 빌드구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 프로그램에 어떠한 영향도 미치지 않는다.
* -Ounchecked 빌드 구성에서는 최적화 중 이 함수가 절대 실행되지 않을 것이라는 가정하에 빌드된다.

### debugPrint

```swift
public func debugPrint(_ items: Any..., seperator: String = " ", terminator: String = "\n")
```
```swift
public func print<Target>(_ items: Any..., seperator: String = " ", terminator: String = "\n", to output: inout Target) where Target : TextOutputStream
```

items을 텍스트 표현으로 표준 출력하거나 output에 작성해 디버깅에 적합하도록 만든다. 출력할 때 자동 줄바꿈을 원하지 않으면 terminator의 값으로 "" 를 전달하면 된다.

### dump

```swift
public func dump<T>(_ value: T, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T
```
```swift
public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T where TargetStream : TextOutputStream
```

표준 출력 또는 지정된 출력 스트림을 통해 객체 내용의 덤프를 생성한다. 출력할 때 자동 줄바꿈을 원하지 않으면 terminator의 값으로 "" 를 전달하면 된다.

### fatalError

```swift
public func fatalError(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never
```

message의 내용을 출력하고 무조건 프로그램 실행을 중단시킨다.

### getVaList

```swift
@inlinable public func getVaList(_ args: [CVarArg]) -> CVaListPointer
```

매개변수를 이용해 전달받은 [CVarArg] 타입을 C 언어의 매개변수 리스트 포인터 타입인 CVaListPointer로 반환한다. CVaListPointer 타입은 C 언어의 va_list 전달인자로 사용할 수 있다. C 언어 함수를 스위프트의 함수로 매핑하는 데 사용하기 좋다. 단, 이 함수보다는 withVaList(_ : _ :) 함수를 사용할 것을 더 권한다.

### max

```swift
@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable
```
```swift
@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable
```

전달인자 중에 가장 큰 값을 반환한다. 만약 동일한 값이 있다면 제일 마지막의 값을 반환한다.

### min

```swift
@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable
```

전달인자 중에 가장 작은 값을 반환한다. 만약 동일한 값이 있다면 제일 처음의 값을 반환한다.

### numericCast

```swift
@inlinable public func numericCast<T, U>(_ x: T) -> U where T : BinaryInteger, U : BinaryInteger
```

정수 타입의 값을 다른 크기의 정수 타입으로 변환해준다. 오버플로가 발생할 경우 런타임 오류가 발생한다.

### precondition

```swift
public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String(), file = #file, line: UInt = #line) 
```

* 플레이그라운드와 -Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 프로그램 실행을 중단한다.
* -Ounchecked 빌드 구성에서는 condition이 실행되지 않지만 최적화 중 true를 반환할 것이라는 가정하에 빌드된다.

### preconditionFailure

```swift
public func preconditionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never
```

* 플레이그라운드와 -Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 message를 출력한 후 프로그램을 중단하고 디버그 가능한 사애로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 프로그램 실행을 중단한다.
* -Ounchecked 빌드 구성에선느 최적화 중 이 함수가 절대 실행되지 않을 것이라는 가정하에 빌드된다.

### print

```swift
public func print(_ items: Any..., seperator: String = " ", terminator: String = "\n")
```
```swift
public func print<Target>(_ items: Any..., sperator: String = " ", terminator: String = "\n", to output: inout Target) where Target : TextOutputStream
```

items의 텍스트 표현을 표준 출력 또는 output에 작성한다. 출력할 때 자동 줄바꿈을 원하지 않는다면 terminator의 값으로 " "을 전달하면 된다.

### readLine

```swift
public func readLine(strippingNewline: Bool = true) -> String?
```

표준 입력을 통해 한 줄씩 혹은 문서의 끝인 **EOF**를 발견할 때까지 읽어 들여 문자열을 반환한다. 표준 입력은 **UTF-8** 형식으로 해석한다. strippingNewline 매개변수에 true를 전달하면 한 줄씩 읽어 들인다. 기본값은 true이다.

### repeatElement

```swift
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T>
```

count 수만큼 element 타입의 Repeated 컬렉션을 생성하여 반환한다.

### swap

```swift
public func swap<T>(_ a: inout T, _ b: inout T)
```

a와 b의 값을 교환한다.

### transcode

```swift
func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, frominputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Void) -> Bool where Input: IteratorProtocol,
InputEncoding : _UnicodeEncoding,
OutputEncoding: _UnicodeEncoding,
Input.Element == InputEncoding.CodeUnit
```

유니코드로 인코딩한 입력값을 다른 유니코드로 인코딩된 값으로 변경한다. 예를 들어 **UTF-8** 형식에서 **UTF-32** 형식으로 변환할 수 있다.

### type

```swift
public func type<T, Metatype>(of value: T) -> Metatype
```

전달받은 값의 메타 타입 인스턴스를 반환한다. 전달받은 값의 타입을 알아낼 때 사용하기 좋다.

### unsafeBitCast

```swift
@inlinable public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U
```

전달받은 값의 비트를 다른 타입의 형식으로 해석하여 반환한다. x는 변환할 값, type은 변환할 타입이다. type은 원래 x와 같은 비트 자릿수를 가진 타입이어야 한다.

### unsafeDowncast

```swift
public func unsafeDowncast<T>(_ x: AnyObject, to type: T.Type) -> T where T : AnyObject
```

x as T와 동일한 결과를 반환한다. 단, x is T가 참이라는 것을 확실할 때만 사용해야한다. 이 함수는 조금이나마 더 안전하게 사용할 수 있는 unsafeBitCast(_ : to :) 함수를 사용할 것을 권한다.

### withoutActuallyEscaping

```swift
public func withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (ClosureType) throws -> ResultType) rethrows -> ResultType
```

비탈출 클로저로 전달된 클로저를 탈출 클로저인 척 실행할 수 있도록 해준다.

### withVaList

```swift
@inlinable public func withVaList<R>(_ args: [CVarArg], _ body: (CVaListPointer) -> R) -> R
```

getVaList(_:) 대신 사용할 수 있는 함수이다. args 매개변수로 전달받은 [CVarArg] 타입의 값들을 CVaListPointer 타입으로 변환한 후 함수의 body 매개변수로 전달받는 클로저의 매개변수로 다시 전달한다. body 클로저는 전달받은 CVaListPointer를 활용하여 결괏값을 만들어 함수의 최종 반환 값으로 한다.

### zip

```swift
@inlinable public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence 
```

두 시퀀스를 하나의 시퀀스로 짝을 이루도록 만들어준다.

표: assert, assertionFailure, fatalError, precondition, preconditionFailure 함수의 실행이 프로그램의 실행에 영향을 미치는지의 여부

||디버그 빌드|배포 빌드|미확인배포 빌드|
|---|---|---|---|
|function|-Onone|-O|-Ounchecked|
|assert()|O|X|X|
|assertionFailure()|O|X|X|
|fatalError()|O|O|O|
|precondition()|O|O|X|
|preconditionFailure()|O|O|X|

-----------
스위프트 주요 함수의 사용
```swift
abs(-100)   // 100
abs(100)    // 100

let int8: Int8 = 5
let int64: Int64 = numericCast(int8)

let zeroes = repeatElement(0, count: 5)
for x in zeroes {
    print(x)
}
// 0
// 0
// 0
// 0
// 0

var valueA: Int = 10
var valueB: Int = 10

assert(valueA == valueB, "valueA != valueB")

debugPrint(valueA, valueB, separator: ",", terminator: "")  // 10,10
debugPrint(valueA, valueB)  // 10 10

dump(valueA)    // 10

// fatalError()

max(1, 3)   // 3
max(1, 2, 3, 4, 5, 6, 7, 8) // 8
min(1, 3)   // 1
min(1, 2, 3, 4, 5, 6, 7, 8) // 1

precondition(valueA == valueB, "valueA != valueB")

print(valueA, valueB, separator: ",", terminator: "")  // 10,10
print(valueA, valueB)  // 10 10


valueA = 100
valueB = 200

swap(&valueA, &valueB)

print(valueA, valueB)   // 200, 100

let words = ["하나", "둘", "셋", "넷"]
let numbers = 1...4

for (word, number) in zip(words, numbers) {
    print("\(word): \(number)")
}
// 하나: 1
// 둘: 2
// 셋: 3
// 넷: 4

let naturalNumbers = 1...Int.max
let zipped = Array(zip(words, naturalNumbers))

print(zipped)
// [("하나", 1), ("둘", 2), ("셋", 3), ("넷", 4)]
```

## C. 스위프트의 예악어

예약어는 프로그래밍 언어에서 미리 사용하기로 약속되어 있는 단어로, 식별자로 사용할 수 없다. 스위프트의 일부 예약어는 강세표(backquote, `)를 사용하여 이름으로 사용할 수 있다.

```swift
class `let` { }
let `self`: `let` = `let`()
func `var` (param: `let`) { }
`var`(param: `self`)
```

### 키워드, 수식어, 특수기호

프로그래밍 언어에서 특정 기능을 실행하기 위해 미리 지정해둔 단어를 키워드라고 한다. 즉, 명령어나 어떤 의미가 부여된 단어이다. 대표적인 키워드로는 var, let, func 등을 예로 들 수 있다. 프로그래밍 언어에서 지정한 키워드는 다른 용도로 사용하거나 다른 식별자(변수, 상수, 함수, 메서드, 타입 등의 이름)로 사용할 수 없다. 그렇지만 몇몇 키워드는 다른 곳에서도 사용이 가능하다. 키워드와 수식어는 프로그래밍 언어에서 사용을 미리 예약해 둔 예약어의 한 종류이다. 또한, 특정 몇몇 특수기호도 예약어로 지정되어 있다.

스위프트에서 사용되는 키워드와 수식어에 대해 알아보겠다.

다음 키워드는 스위프트에서 사용하기로 미리 예약해놓은 키워드로 식별자로 사용할 수 없다. 다만 앞에서 말했듯이 강세표를 사용하면 식별자로 사용할 수 있다. 또, inout, var, let 키워드를 제외한 키워드는 함수의 매개변수 이름 및 전달인자 레이블로 사용할 수 있다.

* 선언에 사용하는 키워드
  * associatedtype
  * class
  * deinit
  * enum
  * extension
  * fileprivate
  * func
  * import
  * init
  * inout
  * internal
  * let
  * open
  * operator
  * private
  * protocol
  * public
  * static
  * struct
  * subscript
  * typealias
  * var
* 구문에 사용하는 키워드
  * break
  * case
  * continue
  * default
  * defer
  * do
  * else
  * fallthrough
  * for
  * guard
  * if
  * in
  * repeat
  * return
  * switch
  * where
  * while
* 패턴에 사용하는 키워드
  * _
* 타입과 기타 표현에 사용하는 키워드
  * as
  * catch
  * false
  * is
  * nil
  * rethrows
  * super
  * self
  * Self
  * throw
  * throws
  * true
  * try
  * #column
  * #file
  * #function
  * #line
  * #sourceLocation
* #으로 시작하는 키워드
  * #available
  * #column
  * #else
  * #elseif
  * #endif
  * #file
  * #function
  * #if
  * #selector
  * #sourceLocation
* 특정 문맥에 의해 예약된 키워드 
  * 해당 키워드를 사용할 만한 문맥의 범위에 해당하지 않을 때에는 식별자(이름)로 사용이 가능
  * assignment
  * associativity
  * convenience
  * dynamic
  * didSet
  * final
  * get
  * higherThan
  * indirect
  * infix
  * lazy
  * left
  * lowerThan
  * mutating
  * none
  * nonmutating
  * optional
  * override
  * postfix
  * precedencegroup
  * prefix
  * Protocol
  * required
  * right
  * set
  * type
  * unowned
  * weak
  * willSet
* 사용자 정의 연산자로 사용이 불가능한 특수기호
  * (,),{,},[,]].,,,:,;,=,@,#,&(전위연산자),->,`,?,!(후위연산자)
* 선언 수식어
  * dynamic
  * final
  * lazy
  * optional
  * required
  * weak
  * open
  * public
  * internal
  * fileprivate
  * private

## D. 디버깅 식별자

프로그램을 빌드하고 실행 중 디버깅을 할 때 유용하게 사용할 수 있는 식별자이다.

* #file: 현재 코드가 실행중인 파일 이름을 나타냄 - String type
* #line: 현재 코드가 실행되고 있는 파일의 몇 번 줄에 위치하는지 나타냄 - Int type
* #column: 현재 코드가 실행되고 있는 줄의 몇 번 칸에 위치하는지 나타냄 - Int type
* #function: 현재 코드가 실행되고 있는 함수의 이름을 나타냄 - String type

```swift
func printDebugInfo() {
    print("\(#file) 파일의 \(#line)번 줄, \(#column)번 칸이고, \(#function) 함수 안에서 실행되고 있다.")
}

printDebugInfo()
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift 파일의 2번 줄, 50번 칸이고, printDebugInfo() 함수 안에서 실행되고 있다.
```

## E. 컴파일러 제어 구문

컴파일러 제어 구문을 사용하면 컴파일에 영향을 줄 수 있다. 스위프트에는 **조건부 컴파일 블록, 라인 제어 구문, 컴파일 시점 진단 구문** 등 세 가지의 **컴파일러 제어 구문**이 있다.

### E.1 조건부 컴파일 블록

조건부 컴파일 블록에서 사용하는 키워드는 #if, #elseif, #endif 등이 있다. 조건부 컴파일블록을 사용하면 컴파일 조건에 맞는 코드는 컴파일 단계에서 포함시키고, 그렇지 않은 코드는 컴파일하지 않는다.

모든 조건부 컴파일 블록은 #if로 시작하여 #endif로 끝난다. #if 외에 다른 조건을 추가 하고 싶다면 #elseif를 사용한다 if-else 구문과 거의 비슷한데, 다만 #endif가 마지막에 꼭 따라붙어야 하며 프로그램 실행 중(런타임)에 동작하는 것이 아니라 컴파일할 때 영향을 준다.

기본적으로 조건부 컴파일 불록은 다음과 같은 형식으로 사용한다.

```swift
#if 컴파일 조건 1
// 컴파일 조건 1이 참이면 컴파일될 코드
#elseif 컴파일 조건 2
// 컴파일 조건 1이 거짓이고 컴파일 조건 2가 참이면 컴파일될 코드
#else
// 컴파일 조건 1과 컴파일 조건 2가 모두 거짓인 경우 컴파일될 코드
#endif
```

컴파일 조건은 Boolean 타입의 값이 들어갈 수 있으며, 빌드 플래그 값이 들어갈 수도 있고, 플랫폼이나 언어 버전을 확인하는 함수가 들어갈 수도 있다. 버전을 확인하는 함수 중 스위프트 버전 확인 함수인 swift() 함수와 컴파일러 버전 확인 함수인 compiler() 함수의 전달인자 값을 전달할 때는 공백이 포함되면 안된다. 또, 비교 연산자는 >=와 <만 사용할 수 있다.

|함수|유효한 전달인자|
|---|---|
|os()|macOS, iOS, watchOS, tvOS, Linux|
|arch()|i386, x86_64, arm, arm64|
|swift(), compiler()|>=버전숫자 혹은 <버전숫자|
|canImport()|모듈 이름|
|targetEnvironment()|simulator|

```swift
#if os(Linux)
    print("이 프로그램은 리눅스 환경을 위해 컴파일 했습니다. ")
#elseif os(macOS)
    print("이 프로그램은 macOS 환경을 위해 컴파일 했습니다. ")
#elseif os(iOS)
    print("이 프로그램은 iOS 환경을 위해 컴파일 했습니다. ")
#else
    print("플랫폼을 인식할 수 없다.")
#endif

#if DEBUG
    print("DEBUG 환경으로 컴파일했습니다. ")
#elseif TEST_RELEASE
    print("TEST_RELEASE 환경으로 컴파일했습니다. ")
#else
    print("RELEASE 환경으로 컴파일했습니다. ")
#endif

#if swift(>=3.0)
    print("Swift 3.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#elseif swift(>=2.0)
    print("Swift 2.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#else
    print("Swift 2.0미만 버전의 환경에서 컴파일했습니다. ")
#endif

#if os(macOS) && swift(<5.0)
    print("macOS를 위해 Swift 5.0 보다 낮은 버전의 환경에서 컴파일했습니다. ")
#elseif os(Linux) || swift(>=3.0)
    print("Linux를 위해 빌드되었거나 Swift 3.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#endif

#if compiler(>=5.0)
    print("스위프트 5.0 이상의 컴파일러에서 컴파일했습니다.")
#endif
#if swift(>=4.2)
    print("스위프트 4.2 이상의 컴파일러에서 컴파일했습니다.")
#endif
#if compiler(>=5.0) && swift(<5.0)
    print("스위프트 5.0 이상의 컴파일러에서 스위프트 5.0 미만의 버전으로 컴파일했습니다. ")
#endif

#if canImport(UIKit)
    print("UIKit을 사용할 수 있습니다. ")
#elseif canImport(AppKit)
    print("AppKit을 사용할 수 있습니다. ")
#else
    print("UIKit과 AppKit을 사용할 수 없습니다.")
#endif

#if targetEnvironment(simulator)
    print("시뮬레이터 환경으로 컴파일했습니다.")
#endif
```

또 한 가지 알아둘 점은 각각의 조건부 컴파일 블록 내부의 코드들은 컴파일이 되든 되지 않든 간에 문법 검사를 하는데, 예외적으로 스위프트 버전 검사를 하는 조건부 컴파일 블록 내부의 코드는 문법 검사를 하지 않는다. 언어의 버전이 변경됨에 따라 변경된 문법이 컴파일 오류로 처리되지 않게 하기 위함이다.

```swift
var i: Int = 0

#if swift(>=2.2)
    i += 1
#else
    i++
#endif

print(i)    // 1

#if compiler(<2.2)
    i++
#else
    i += 1
#endif

print(i)    // 2
```

### E.2 라인 제어 구문

**라인 제어 구문**은 라인 번호와 파일 이름을 소스 코드가 컴파일할 때 다른 라인 번호와 파일 이름으로 사용하도록 의도적으로 변경하고 싶을 때 사용한다. 디버깅과 진단 목적에 따라 라인 제어 구문을 사용하여 디버깅 로그에 출력할 소스 코드의 위치를 변경할 수 있다. 즉, 라인 제어 구문은 파일 이름과 라인 번호를 실제 컴파일한 파일의 환경과 다르게 변경할 수 있는 기능이다. 라인 제어 구문을 통해 #file, #line의 값을 프로그래머 마음대로 변경해주거나 초기화해줄 수 있다.

라인 제어 구문은 #sourceLocation을 사용하며, 두 가지 방법으로 사용할 수 있다.

```swift
#sourceLocation(file: 파일 이름, line: 라인 번호)
#sourceLocation()
```

먼저 #sourceLocation(file: 파일 이름, line: 라인 번호)처럼 사용하면 #file과 #line의 리터럴 표현의 값을 변경한다. 파일 이름은 문자열 값이어야 하며 라인 번호는 0이상의 정수값이어야 한다.

또는 #sourceLocation()처럼 사용하면 #sourceLocation(file: 파일 이름, line: 라인 번호)가 변경해 둔 #file과 #line의 값을 원래 파일에서의 위치대로 복원해준다. #sourceLocation(file: 파일 이름, line: 라인 번호) 구문이 선행된 이후 사용해주어야 한다.

### E.3 컴파일 시점 진단 구문

컴파일 시점 진단 구문을 사용하면 컴파일러가 컴파일하는 도중에 오류나 경고가 발생한다. 문법적으로 오류가 있어서 오류나 경고가 발생하는 것이 아니라 프로그래머가 의도적으로 오류나 경고를 발생시키고자 할 때 사용한다. 차후에 특정 위치에 코드를 작성해야 하는데 깜빡할 것 같을 때 사용하면 유용한 기능이다.

#error("오류 메시지")를 사용하면 컴파일시점에 **"오류 메시지"** 가 발생하면서 컴파일이 중단된다. #waring("경고 메시지")을 사용하면 컴파일시점에 **"경고 메시지"** 를 출력한다. 컴파일이 중단되지는 않는다. 오류 메시지나 경고 메시지에는 문자열 보간법을 사용할 수 없다.

```swift
import Swift

print("\(#file)의 \(#line)번 줄에서 실행되고 있습니다.")
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift의 3번 줄에서 실행되고 있습니다.

#sourceLocation(file: "main.swift", line: 100)
func printDebugInfo() {
    print("\(#file) 파일의 \(#line)번 줄, \(#column)번 칸이고, \(#function) 함수 안에서 실행되고 있습니다.")
}

printDebugInfo()
// main.swift 파일의 101번 줄, 50번 칸이고, printDebugInfo() 함수 안에서 실행되고 있습니다.

#sourceLocation()

print("\(#file)의 \(#line)번 줄에서 실행되고 있습니다.")
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift의 16번 줄에서 실행되고 있습니다.

#warning("여기에 작성할 코드가 있을텐데요! 혹시 잊은 것이 없는지 확인해보세요!")
#error("여기에 코드 작성 안하면 오류가 발생해요!")
```

## F. 사용 가능 조건 확인

**사용 가능 조건** 을 이용하면 프로그램 실행 중 동적으로 API 사용이 가능한지 판단 할 수 있다. if, while, guard 등의 구문과 함께 사용할 수 있다.

사용 가능 조건은 기본적으로 다음과 같은 모양으로 사용할 수 있다.

```swift
if #available(플랫폼 이름 버전, *) {
    // API가 사용 가능하면 실행할 코드
} else {
    // API가 사용이 불가능하면 실행할 코드
}
```

사용 가능 조건을 통해 프로그램을 실행하는 도중에 동적으로 API 사용이 가능한지 확인하여 특정 코드를실행할 수 있도록 한다. 컴파일러는 사용 가능 조건을 통해 API를 확인하여 블록 내부의 코드를 실행할 수 있을지 판단한다.

사용 가능 조건은 플랫폼 이름과 버전의 목록 형식으로 작성한다. iOS, macOS, watchOS 등의 플랫폼 이름을 사용할 수 있으며, 버전 숫자를 포함하여 표현해준다. 에스터리스크(*) 전달인자는 모든 플랫폼을 뜻한다. 플랫폼 조건 뒤에 마지막에는 꼭 *을 붙여주어야 한다. 사용 가능 조건은 && || 등의 논리연산을 통해 조건을 추가하거나 병합할 수 없다.

```swift
if #available(iOS 11, *) {
    print("iOS 11 이상의 버전에서 실행 중입니다.")
} else if #available(iOS 10, *) {
    print("iOS 10 이상의 버전에서 실행 중입니다.")
} else {
    print("iOS 10 미만의 버전에서 실행 중입니다.")
}

if #available(iOS 11.0, macOS 10.13, *) {
    print("iOS 11.0 이상 또는 macOS의 10.13 이상의 버전에서 실행 중입니다.")
} else if #available(watchOS 4.0, *) {
    print("watchOS 4.0 이상의 버전에서 실행 중입니다.")
} else {
    print("그 외 기타 플랫폼")
}

while true {
    guard #available(iOS 9.0, *) else {
        print("iOS 9.0 미만의 버전입니다.")
        break
    }
}
```

사용 가능 조건을 실행 중에 확인할 수도 있지만, 프로그래머가 직접 함수, 메서드, 클래스, 구조체, 열거형 등에 사용 가능한 조건을 명시해줄 수도 있다. @available 표현을 사용하면 해당 코드 블록은 @available에 명시된 조건을 충족해야 사용할 수 있다. 또, 현재 빌드한 환경이 @available 속성과 맞지 않는다면 해당 코드 블록은 컴파일되지 않는다. 저장 프로퍼티에는 사용 가능 조건을 줄 수 없다. @available에 대한 자세한 설명은 속성에서 이어서 자세히 다룬다.