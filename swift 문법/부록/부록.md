# 부록

스위프트 사용 시 미리 알아두면 도움이 될 만한 내용을 부록으로 모았다.

스위프트에 관련된 더 자세하고 많은 사항은 스위프트 문서와 스위프트 블로그에서 확인할 수 있다. 기술 문서를 읽는 습관을 들이면 개발에 도움이 되리라 생각한다.

## A. 스위프트의 주요 프로토콜

스위프트 표준 라이브러리에 정의된 주요 프로토콜을 알아두면 스위프트의 기본 기능을 후러씬 편리하게 활용할 수 있을 것이다. 또, 각각의 프로토콜 정의를 살펴보면 더욱 유용할 것이다. 스위프트 문서를 참고하면 프로토콜 간의 상관관계 도한 쉽게 알아볼 수 있다.

|프로토콜 이름|설명|
|---|---|
|AnyObject|모든 클래스 타입이 암시적으로 준수하는 프로토콜|
|BinaryInteger|스위프트의 정수 타입을 위한 요구사항|
|CaseIterable|연관값이 없는 열거형인 경우에 CaseIterable 프로토콜을 준수하면 각각의 case를 순회할 수 있다. 순회할 case는 allCases 콜렉션으로 제공|
|Codable|Encodable과 Decodable의 합성 프로토콜이다. Codable 프로토콜을 준수하는 타입은 다른 표현방식으로 상호 변환할 수 있다. 대표적인 예로 스위프트의 인스턴스를 JSON 문자열로 변환하고, 반대로 JSON 문자열을 스위프트의 인스턴스로 상호 변환할 수 있는 기능을 제공한다.|
|CodingKey|인코딩과 디코딩의 키로 활용할 타입|
|Collection|요소에 인덱스와 서브스크립트로 접근할 수 있는 시퀀스|
|Comparable|관계 연산자(<,> 등등)을 사용해 비교할 수 있는 타입이다. 숫자나 문자열처럼 순서를 갖는 타입에 사용하기 적합핟. 스위프트 표준 라이브러리의 대부분의 타입은 Comparable 프로토콜을 준수한다.|
|CustomString Convertible|사용자 정의 텍스트 표현을 할 수 있는 타입이다. 사용자 정의 텍스트 표현은 print 등의 함수에서 사용하는 출력 스트림에 쓰일 수 있다.
|Equatable|== 및 != 연산자를 사용하여 값이 동일한지 판단할 수 있는 타입이다. 스위프트 표준 라이브러리에 정의된 타입 대부분은 Equatable 프로토콜을 준수한다. 사용자 정의 타입에서 Equatable 프로토콜을 채택하면 해당 타입을 위한 == 연산자를 구현해야 한다. 그러면 표준 라이브러리에서 != 연산자를 자동으로 구현해준다.
|Error|던질 수 있는 요류를 표현하는 타입이다. Error 프로토콜을 준수하는 타입은 스위프트의 오류처리 시스템의 오류를 표현한다. Error 프로토콜을 별다른 요구사항 정의가 없으므로 어떤 타입이든 채택하면 준수할 수 있다. 열거형 타입을 활용하여 오류를 표현하는 데 많이 사용한다.
|FixedWidthInteger|정수 오버플로 연산을 지원하기 위한 요구사항
|Hashable|정수 해시 값을 제공하고 Dictionay의 키가 될 수 있는 타입
|IteratorProtocol|시퀀스를 통한 반복을 위해 반복 상태와 인터페이스를 캡슐화함|
|Sequence|for-in 구문을 통해 반복될 수 있는 타입
|SignedInteger|스위프트의 부호가 있는 정수 타입을 위한 요구사항
|SignedNumeric|뺄셈 연산이 가능하며 음의 표현이 가능하고 0으로 초기화될 수 있는 타입
|TextOutputStreamable|텍스트 스트리밍 기능을 실행할 수 있는 타입이다. TextOutputStreamable 인스턴스는 어떤 출력 스트림이든 쓰일 수 있다. TextOutputStreamable 프로토콜을 준수하는 대표적인 타입으로 String, Character, UnicodeScalar 등이 있다.
|UnsignedInteger|스위프트의 부호가 없는 정수 타입을 위한 요구사항

### ExpressibleByLiteral

리터럴은 코드에 쓰인 값의 타입대로 그 타입의 인스턴스를 생성할 수 있도록 하는 표현이다. ExpressibleByLiteral 종류의 프로토콜은 말 그대로, 코드에 쓰이는 그대로 자신의 타입으로 인스턴스를 초기화하고 생성할 수 있는 타입의 프로토콜을 뜻한다.

예를 들어 ExpressibleByArrayLiteral 프로토콜을 준수한다면, 배열 리터럴로 자신의 인스턴스를 초기화할 수 있는 타입이 된다는 것을 뜻한다.

Set 타입은 ExpressibleByArrayLiteral 프로토콜을 준수한다. 그래서 let aSet: Set<Int> = [1, 2, 3] 처럼 표현할 수 있다.

|프토토콜 이름|설명|
|---|---|
|ExpressibleByArrayLiteral|배열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByBooleanLiteral|불리언 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByDictionaryLiteral|딕셔너리 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByFloatLiteral|부동소수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByIntegerLiteral|정수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByNilLiteral|nil 통해 초기화할 수 있는 타입|
|ExpressibleByStringLiteral|문자열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByUnicodeScalarLiteral|유니코드 스칼라 값을 갖는 하나의 문자를 갖는 문자열 리터럴을 통해 초기화할 수 있는 타입|
