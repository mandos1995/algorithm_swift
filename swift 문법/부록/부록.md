# 부록

스위프트 사용 시 미리 알아두면 도움이 될 만한 내용을 부록으로 모았다.

스위프트에 관련된 더 자세하고 많은 사항은 스위프트 문서와 스위프트 블로그에서 확인할 수 있다. 기술 문서를 읽는 습관을 들이면 개발에 도움이 되리라 생각한다.

## A. 스위프트의 주요 프로토콜

스위프트 표준 라이브러리에 정의된 주요 프로토콜을 알아두면 스위프트의 기본 기능을 후러씬 편리하게 활용할 수 있을 것이다. 또, 각각의 프로토콜 정의를 살펴보면 더욱 유용할 것이다. 스위프트 문서를 참고하면 프로토콜 간의 상관관계 도한 쉽게 알아볼 수 있다.

|프로토콜 이름|설명|
|---|---|
|AnyObject|모든 클래스 타입이 암시적으로 준수하는 프로토콜|
|BinaryInteger|스위프트의 정수 타입을 위한 요구사항|
|CaseIterable|연관값이 없는 열거형인 경우에 CaseIterable 프로토콜을 준수하면 각각의 case를 순회할 수 있다. 순회할 case는 allCases 콜렉션으로 제공|
|Codable|Encodable과 Decodable의 합성 프로토콜이다. Codable 프로토콜을 준수하는 타입은 다른 표현방식으로 상호 변환할 수 있다. 대표적인 예로 스위프트의 인스턴스를 JSON 문자열로 변환하고, 반대로 JSON 문자열을 스위프트의 인스턴스로 상호 변환할 수 있는 기능을 제공한다.|
|CodingKey|인코딩과 디코딩의 키로 활용할 타입|
|Collection|요소에 인덱스와 서브스크립트로 접근할 수 있는 시퀀스|
|Comparable|관계 연산자(<,> 등등)을 사용해 비교할 수 있는 타입이다. 숫자나 문자열처럼 순서를 갖는 타입에 사용하기 적합핟. 스위프트 표준 라이브러리의 대부분의 타입은 Comparable 프로토콜을 준수한다.|
|CustomString Convertible|사용자 정의 텍스트 표현을 할 수 있는 타입이다. 사용자 정의 텍스트 표현은 print 등의 함수에서 사용하는 출력 스트림에 쓰일 수 있다.
|Equatable|== 및 != 연산자를 사용하여 값이 동일한지 판단할 수 있는 타입이다. 스위프트 표준 라이브러리에 정의된 타입 대부분은 Equatable 프로토콜을 준수한다. 사용자 정의 타입에서 Equatable 프로토콜을 채택하면 해당 타입을 위한 == 연산자를 구현해야 한다. 그러면 표준 라이브러리에서 != 연산자를 자동으로 구현해준다.
|Error|던질 수 있는 요류를 표현하는 타입이다. Error 프로토콜을 준수하는 타입은 스위프트의 오류처리 시스템의 오류를 표현한다. Error 프로토콜을 별다른 요구사항 정의가 없으므로 어떤 타입이든 채택하면 준수할 수 있다. 열거형 타입을 활용하여 오류를 표현하는 데 많이 사용한다.
|FixedWidthInteger|정수 오버플로 연산을 지원하기 위한 요구사항
|Hashable|정수 해시 값을 제공하고 Dictionay의 키가 될 수 있는 타입
|IteratorProtocol|시퀀스를 통한 반복을 위해 반복 상태와 인터페이스를 캡슐화함|
|Sequence|for-in 구문을 통해 반복될 수 있는 타입
|SignedInteger|스위프트의 부호가 있는 정수 타입을 위한 요구사항
|SignedNumeric|뺄셈 연산이 가능하며 음의 표현이 가능하고 0으로 초기화될 수 있는 타입
|TextOutputStreamable|텍스트 스트리밍 기능을 실행할 수 있는 타입이다. TextOutputStreamable 인스턴스는 어떤 출력 스트림이든 쓰일 수 있다. TextOutputStreamable 프로토콜을 준수하는 대표적인 타입으로 String, Character, UnicodeScalar 등이 있다.
|UnsignedInteger|스위프트의 부호가 없는 정수 타입을 위한 요구사항

### ExpressibleByLiteral

리터럴은 코드에 쓰인 값의 타입대로 그 타입의 인스턴스를 생성할 수 있도록 하는 표현이다. ExpressibleByLiteral 종류의 프로토콜은 말 그대로, 코드에 쓰이는 그대로 자신의 타입으로 인스턴스를 초기화하고 생성할 수 있는 타입의 프로토콜을 뜻한다.

예를 들어 ExpressibleByArrayLiteral 프로토콜을 준수한다면, 배열 리터럴로 자신의 인스턴스를 초기화할 수 있는 타입이 된다는 것을 뜻한다.

Set 타입은 ExpressibleByArrayLiteral 프로토콜을 준수한다. 그래서 let aSet: Set<Int> = [1, 2, 3] 처럼 표현할 수 있다.

|프토토콜 이름|설명|
|---|---|
|ExpressibleByArrayLiteral|배열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByBooleanLiteral|불리언 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByDictionaryLiteral|딕셔너리 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByFloatLiteral|부동소수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByIntegerLiteral|정수 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByNilLiteral|nil 통해 초기화할 수 있는 타입|
|ExpressibleByStringLiteral|문자열 리터럴을 통해 초기화할 수 있는 타입|
|ExpressibleByUnicodeScalarLiteral|유니코드 스칼라 값을 갖는 하나의 문자를 갖는 문자열 리터럴을 통해 초기화할 수 있는 타입|

## B. 스위프트의 주요 함수

스위프트 표준 라이브러리에서 기본적으로 제공하는 함수에 대해 알아보자. 해당 함수들은 전역함수이므로 새로운 함수를 정의할 때 이름이 중복되지 않도록 주의를 기울이는 것이 좋다.

### abs

```swift
@inlinable public func abs<T>(_ x: T) -> T where T : Comparable, T : SignedNumeric
```

전달인자로 전달받은 값의 절대 값을 반환하는 함수

### assert

```swift
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String (), file: StaticString = #file, line: UInt = #line)
```

전통적인 C 스타일의 Assert를 위해 제공하는 함수이다. 실제 배포하는 빌드에서는 전혀 영향을 미치지 않으며 실제 배포하는 코드에는 precondtion 함수를 사용하는 것이 좋다.

* 플레이그라운드와 - Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 condition이 실행되지 않으며, 프로그램에 어떠한 영향도 미치지 않는다.
* -Ounchecked 빌드 구성에서는 condition이 실행되지 않지만 최적화 중 true를 반환할 것이라는 가정하에 빌드된다.

**NOTE_빌드구성**

-Onone, -O, -Ounchecked 구성은 사실 디버그, 배포, 미확인배포 등을 위한 빌드 구성이 아니라 스위프트 최적화 단계 옵션 구성이다. Xcode에서 각각 디버그, 배포, 미확인배포 등에 기본적으로 적용되는 구성이다.

### assertionFailure

```swift
@inlinable public func assertionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line)
```

배포 버전 빌드에는 영향을 미치지 않지만, 디버그용 빌드에서 프로그램을 중단하고 디버그 가능한 상태로 전환하고 싶을 때 사용한다.

* 플레이그라운드와 -Onone 빌드구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 프로그램에 어떠한 영향도 미치지 않는다.
* -Ounchecked 빌드 구성에서는 최적화 중 이 함수가 절대 실행되지 않을 것이라는 가정하에 빌드된다.

### debugPrint

```swift
public func debugPrint(_ items: Any..., seperator: String = " ", terminator: String = "\n")
```
```swift
public func print<Target>(_ items: Any..., seperator: String = " ", terminator: String = "\n", to output: inout Target) where Target : TextOutputStream
```

items을 텍스트 표현으로 표준 출력하거나 output에 작성해 디버깅에 적합하도록 만든다. 출력할 때 자동 줄바꿈을 원하지 않으면 terminator의 값으로 "" 를 전달하면 된다.

### dump

```swift
public func dump<T>(_ value: T, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T
```
```swift
public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T where TargetStream : TextOutputStream
```

표준 출력 또는 지정된 출력 스트림을 통해 객체 내용의 덤프를 생성한다. 출력할 때 자동 줄바꿈을 원하지 않으면 terminator의 값으로 "" 를 전달하면 된다.

### fatalError

```swift
public func fatalError(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never
```

message의 내용을 출력하고 무조건 프로그램 실행을 중단시킨다.

### getVaList

```swift
@inlinable public func getVaList(_ args: [CVarArg]) -> CVaListPointer
```

매개변수를 이용해 전달받은 [CVarArg] 타입을 C 언어의 매개변수 리스트 포인터 타입인 CVaListPointer로 반환한다. CVaListPointer 타입은 C 언어의 va_list 전달인자로 사용할 수 있다. C 언어 함수를 스위프트의 함수로 매핑하는 데 사용하기 좋다. 단, 이 함수보다는 withVaList(_ : _ :) 함수를 사용할 것을 더 권한다.

### max

```swift
@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable
```
```swift
@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable
```

전달인자 중에 가장 큰 값을 반환한다. 만약 동일한 값이 있다면 제일 마지막의 값을 반환한다.

### min

```swift
@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable
```

전달인자 중에 가장 작은 값을 반환한다. 만약 동일한 값이 있다면 제일 처음의 값을 반환한다.

### numericCast

```swift
@inlinable public func numericCast<T, U>(_ x: T) -> U where T : BinaryInteger, U : BinaryInteger
```

정수 타입의 값을 다른 크기의 정수 타입으로 변환해준다. 오버플로가 발생할 경우 런타임 오류가 발생한다.

### precondition

```swift
public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String(), file = #file, line: UInt = #line) 
```

* 플레이그라운드와 -Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 message를 출력한 후 프로그램을 중단하고 디버그 가능한 상태로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 condition 실행 결과가 false라면 프로그램 실행을 중단한다.
* -Ounchecked 빌드 구성에서는 condition이 실행되지 않지만 최적화 중 true를 반환할 것이라는 가정하에 빌드된다.

### preconditionFailure

```swift
public func preconditionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never
```

* 플레이그라운드와 -Onone 빌드 구성(Xcode의 디버그용 빌드 기본 구성)을 사용하는 빌드에서는 message를 출력한 후 프로그램을 중단하고 디버그 가능한 사애로 전환된다.
* -O 빌드 구성(Xcode의 배포용 빌드 기본 구성)을 사용하는 빌드에서는 프로그램 실행을 중단한다.
* -Ounchecked 빌드 구성에선느 최적화 중 이 함수가 절대 실행되지 않을 것이라는 가정하에 빌드된다.

### print

```swift
public func print(_ items: Any..., seperator: String = " ", terminator: String = "\n")
```
```swift
public func print<Target>(_ items: Any..., sperator: String = " ", terminator: String = "\n", to output: inout Target) where Target : TextOutputStream
```

items의 텍스트 표현을 표준 출력 또는 output에 작성한다. 출력할 때 자동 줄바꿈을 원하지 않는다면 terminator의 값으로 " "을 전달하면 된다.

### readLine

```swift
public func readLine(strippingNewline: Bool = true) -> String?
```

표준 입력을 통해 한 줄씩 혹은 문서의 끝인 **EOF**를 발견할 때까지 읽어 들여 문자열을 반환한다. 표준 입력은 **UTF-8** 형식으로 해석한다. strippingNewline 매개변수에 true를 전달하면 한 줄씩 읽어 들인다. 기본값은 true이다.

### repeatElement

```swift
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T>
```

count 수만큼 element 타입의 Repeated 컬렉션을 생성하여 반환한다.

### swap

```swift
public func swap<T>(_ a: inout T, _ b: inout T)
```

a와 b의 값을 교환한다.

### transcode

```swift
func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, frominputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Void) -> Bool where Input: IteratorProtocol,
InputEncoding : _UnicodeEncoding,
OutputEncoding: _UnicodeEncoding,
Input.Element == InputEncoding.CodeUnit
```

유니코드로 인코딩한 입력값을 다른 유니코드로 인코딩된 값으로 변경한다. 예를 들어 **UTF-8** 형식에서 **UTF-32** 형식으로 변환할 수 있다.

### type

```swift
public func type<T, Metatype>(of value: T) -> Metatype
```

전달받은 값의 메타 타입 인스턴스를 반환한다. 전달받은 값의 타입을 알아낼 때 사용하기 좋다.

### unsafeBitCast

```swift
@inlinable public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U
```

전달받은 값의 비트를 다른 타입의 형식으로 해석하여 반환한다. x는 변환할 값, type은 변환할 타입이다. type은 원래 x와 같은 비트 자릿수를 가진 타입이어야 한다.

### unsafeDowncast

```swift
public func unsafeDowncast<T>(_ x: AnyObject, to type: T.Type) -> T where T : AnyObject
```

x as T와 동일한 결과를 반환한다. 단, x is T가 참이라는 것을 확실할 때만 사용해야한다. 이 함수는 조금이나마 더 안전하게 사용할 수 있는 unsafeBitCast(_ : to :) 함수를 사용할 것을 권한다.

### withoutActuallyEscaping

```swift
public func withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (ClosureType) throws -> ResultType) rethrows -> ResultType
```

비탈출 클로저로 전달된 클로저를 탈출 클로저인 척 실행할 수 있도록 해준다.

### withVaList

```swift
@inlinable public func withVaList<R>(_ args: [CVarArg], _ body: (CVaListPointer) -> R) -> R
```

getVaList(_:) 대신 사용할 수 있는 함수이다. args 매개변수로 전달받은 [CVarArg] 타입의 값들을 CVaListPointer 타입으로 변환한 후 함수의 body 매개변수로 전달받는 클로저의 매개변수로 다시 전달한다. body 클로저는 전달받은 CVaListPointer를 활용하여 결괏값을 만들어 함수의 최종 반환 값으로 한다.

### zip

```swift
@inlinable public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence 
```

두 시퀀스를 하나의 시퀀스로 짝을 이루도록 만들어준다.

표: assert, assertionFailure, fatalError, precondition, preconditionFailure 함수의 실행이 프로그램의 실행에 영향을 미치는지의 여부

||디버그 빌드|배포 빌드|미확인배포 빌드|
|---|---|---|---|
|function|-Onone|-O|-Ounchecked|
|assert()|O|X|X|
|assertionFailure()|O|X|X|
|fatalError()|O|O|O|
|precondition()|O|O|X|
|preconditionFailure()|O|O|X|

-----------
스위프트 주요 함수의 사용
```swift
abs(-100)   // 100
abs(100)    // 100

let int8: Int8 = 5
let int64: Int64 = numericCast(int8)

let zeroes = repeatElement(0, count: 5)
for x in zeroes {
    print(x)
}
// 0
// 0
// 0
// 0
// 0

var valueA: Int = 10
var valueB: Int = 10

assert(valueA == valueB, "valueA != valueB")

debugPrint(valueA, valueB, separator: ",", terminator: "")  // 10,10
debugPrint(valueA, valueB)  // 10 10

dump(valueA)    // 10

// fatalError()

max(1, 3)   // 3
max(1, 2, 3, 4, 5, 6, 7, 8) // 8
min(1, 3)   // 1
min(1, 2, 3, 4, 5, 6, 7, 8) // 1

precondition(valueA == valueB, "valueA != valueB")

print(valueA, valueB, separator: ",", terminator: "")  // 10,10
print(valueA, valueB)  // 10 10


valueA = 100
valueB = 200

swap(&valueA, &valueB)

print(valueA, valueB)   // 200, 100

let words = ["하나", "둘", "셋", "넷"]
let numbers = 1...4

for (word, number) in zip(words, numbers) {
    print("\(word): \(number)")
}
// 하나: 1
// 둘: 2
// 셋: 3
// 넷: 4

let naturalNumbers = 1...Int.max
let zipped = Array(zip(words, naturalNumbers))

print(zipped)
// [("하나", 1), ("둘", 2), ("셋", 3), ("넷", 4)]
```

## C. 스위프트의 예악어

예약어는 프로그래밍 언어에서 미리 사용하기로 약속되어 있는 단어로, 식별자로 사용할 수 없다. 스위프트의 일부 예약어는 강세표(backquote, `)를 사용하여 이름으로 사용할 수 있다.

```swift
class `let` { }
let `self`: `let` = `let`()
func `var` (param: `let`) { }
`var`(param: `self`)
```

### 키워드, 수식어, 특수기호

프로그래밍 언어에서 특정 기능을 실행하기 위해 미리 지정해둔 단어를 키워드라고 한다. 즉, 명령어나 어떤 의미가 부여된 단어이다. 대표적인 키워드로는 var, let, func 등을 예로 들 수 있다. 프로그래밍 언어에서 지정한 키워드는 다른 용도로 사용하거나 다른 식별자(변수, 상수, 함수, 메서드, 타입 등의 이름)로 사용할 수 없다. 그렇지만 몇몇 키워드는 다른 곳에서도 사용이 가능하다. 키워드와 수식어는 프로그래밍 언어에서 사용을 미리 예약해 둔 예약어의 한 종류이다. 또한, 특정 몇몇 특수기호도 예약어로 지정되어 있다.

스위프트에서 사용되는 키워드와 수식어에 대해 알아보겠다.

다음 키워드는 스위프트에서 사용하기로 미리 예약해놓은 키워드로 식별자로 사용할 수 없다. 다만 앞에서 말했듯이 강세표를 사용하면 식별자로 사용할 수 있다. 또, inout, var, let 키워드를 제외한 키워드는 함수의 매개변수 이름 및 전달인자 레이블로 사용할 수 있다.

* 선언에 사용하는 키워드
  * associatedtype
  * class
  * deinit
  * enum
  * extension
  * fileprivate
  * func
  * import
  * init
  * inout
  * internal
  * let
  * open
  * operator
  * private
  * protocol
  * public
  * static
  * struct
  * subscript
  * typealias
  * var
* 구문에 사용하는 키워드
  * break
  * case
  * continue
  * default
  * defer
  * do
  * else
  * fallthrough
  * for
  * guard
  * if
  * in
  * repeat
  * return
  * switch
  * where
  * while
* 패턴에 사용하는 키워드
  * _
* 타입과 기타 표현에 사용하는 키워드
  * as
  * catch
  * false
  * is
  * nil
  * rethrows
  * super
  * self
  * Self
  * throw
  * throws
  * true
  * try
  * #column
  * #file
  * #function
  * #line
  * #sourceLocation
* #으로 시작하는 키워드
  * #available
  * #column
  * #else
  * #elseif
  * #endif
  * #file
  * #function
  * #if
  * #selector
  * #sourceLocation
* 특정 문맥에 의해 예약된 키워드 
  * 해당 키워드를 사용할 만한 문맥의 범위에 해당하지 않을 때에는 식별자(이름)로 사용이 가능
  * assignment
  * associativity
  * convenience
  * dynamic
  * didSet
  * final
  * get
  * higherThan
  * indirect
  * infix
  * lazy
  * left
  * lowerThan
  * mutating
  * none
  * nonmutating
  * optional
  * override
  * postfix
  * precedencegroup
  * prefix
  * Protocol
  * required
  * right
  * set
  * type
  * unowned
  * weak
  * willSet
* 사용자 정의 연산자로 사용이 불가능한 특수기호
  * (,),{,},[,]].,,,:,;,=,@,#,&(전위연산자),->,`,?,!(후위연산자)
* 선언 수식어
  * dynamic
  * final
  * lazy
  * optional
  * required
  * weak
  * open
  * public
  * internal
  * fileprivate
  * private

## D. 디버깅 식별자

프로그램을 빌드하고 실행 중 디버깅을 할 때 유용하게 사용할 수 있는 식별자이다.

* #file: 현재 코드가 실행중인 파일 이름을 나타냄 - String type
* #line: 현재 코드가 실행되고 있는 파일의 몇 번 줄에 위치하는지 나타냄 - Int type
* #column: 현재 코드가 실행되고 있는 줄의 몇 번 칸에 위치하는지 나타냄 - Int type
* #function: 현재 코드가 실행되고 있는 함수의 이름을 나타냄 - String type

```swift
func printDebugInfo() {
    print("\(#file) 파일의 \(#line)번 줄, \(#column)번 칸이고, \(#function) 함수 안에서 실행되고 있다.")
}

printDebugInfo()
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift 파일의 2번 줄, 50번 칸이고, printDebugInfo() 함수 안에서 실행되고 있다.
```

## E. 컴파일러 제어 구문

컴파일러 제어 구문을 사용하면 컴파일에 영향을 줄 수 있다. 스위프트에는 **조건부 컴파일 블록, 라인 제어 구문, 컴파일 시점 진단 구문** 등 세 가지의 **컴파일러 제어 구문**이 있다.

### E.1 조건부 컴파일 블록

조건부 컴파일 블록에서 사용하는 키워드는 #if, #elseif, #endif 등이 있다. 조건부 컴파일블록을 사용하면 컴파일 조건에 맞는 코드는 컴파일 단계에서 포함시키고, 그렇지 않은 코드는 컴파일하지 않는다.

모든 조건부 컴파일 블록은 #if로 시작하여 #endif로 끝난다. #if 외에 다른 조건을 추가 하고 싶다면 #elseif를 사용한다 if-else 구문과 거의 비슷한데, 다만 #endif가 마지막에 꼭 따라붙어야 하며 프로그램 실행 중(런타임)에 동작하는 것이 아니라 컴파일할 때 영향을 준다.

기본적으로 조건부 컴파일 불록은 다음과 같은 형식으로 사용한다.

```swift
#if 컴파일 조건 1
// 컴파일 조건 1이 참이면 컴파일될 코드
#elseif 컴파일 조건 2
// 컴파일 조건 1이 거짓이고 컴파일 조건 2가 참이면 컴파일될 코드
#else
// 컴파일 조건 1과 컴파일 조건 2가 모두 거짓인 경우 컴파일될 코드
#endif
```

컴파일 조건은 Boolean 타입의 값이 들어갈 수 있으며, 빌드 플래그 값이 들어갈 수도 있고, 플랫폼이나 언어 버전을 확인하는 함수가 들어갈 수도 있다. 버전을 확인하는 함수 중 스위프트 버전 확인 함수인 swift() 함수와 컴파일러 버전 확인 함수인 compiler() 함수의 전달인자 값을 전달할 때는 공백이 포함되면 안된다. 또, 비교 연산자는 >=와 <만 사용할 수 있다.

|함수|유효한 전달인자|
|---|---|
|os()|macOS, iOS, watchOS, tvOS, Linux|
|arch()|i386, x86_64, arm, arm64|
|swift(), compiler()|>=버전숫자 혹은 <버전숫자|
|canImport()|모듈 이름|
|targetEnvironment()|simulator|

```swift
#if os(Linux)
    print("이 프로그램은 리눅스 환경을 위해 컴파일 했습니다. ")
#elseif os(macOS)
    print("이 프로그램은 macOS 환경을 위해 컴파일 했습니다. ")
#elseif os(iOS)
    print("이 프로그램은 iOS 환경을 위해 컴파일 했습니다. ")
#else
    print("플랫폼을 인식할 수 없다.")
#endif

#if DEBUG
    print("DEBUG 환경으로 컴파일했습니다. ")
#elseif TEST_RELEASE
    print("TEST_RELEASE 환경으로 컴파일했습니다. ")
#else
    print("RELEASE 환경으로 컴파일했습니다. ")
#endif

#if swift(>=3.0)
    print("Swift 3.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#elseif swift(>=2.0)
    print("Swift 2.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#else
    print("Swift 2.0미만 버전의 환경에서 컴파일했습니다. ")
#endif

#if os(macOS) && swift(<5.0)
    print("macOS를 위해 Swift 5.0 보다 낮은 버전의 환경에서 컴파일했습니다. ")
#elseif os(Linux) || swift(>=3.0)
    print("Linux를 위해 빌드되었거나 Swift 3.0과 같거나 높은 버전의 환경에서 컴파일했습니다. ")
#endif

#if compiler(>=5.0)
    print("스위프트 5.0 이상의 컴파일러에서 컴파일했습니다.")
#endif
#if swift(>=4.2)
    print("스위프트 4.2 이상의 컴파일러에서 컴파일했습니다.")
#endif
#if compiler(>=5.0) && swift(<5.0)
    print("스위프트 5.0 이상의 컴파일러에서 스위프트 5.0 미만의 버전으로 컴파일했습니다. ")
#endif

#if canImport(UIKit)
    print("UIKit을 사용할 수 있습니다. ")
#elseif canImport(AppKit)
    print("AppKit을 사용할 수 있습니다. ")
#else
    print("UIKit과 AppKit을 사용할 수 없습니다.")
#endif

#if targetEnvironment(simulator)
    print("시뮬레이터 환경으로 컴파일했습니다.")
#endif
```

또 한 가지 알아둘 점은 각각의 조건부 컴파일 블록 내부의 코드들은 컴파일이 되든 되지 않든 간에 문법 검사를 하는데, 예외적으로 스위프트 버전 검사를 하는 조건부 컴파일 블록 내부의 코드는 문법 검사를 하지 않는다. 언어의 버전이 변경됨에 따라 변경된 문법이 컴파일 오류로 처리되지 않게 하기 위함이다.

```swift
var i: Int = 0

#if swift(>=2.2)
    i += 1
#else
    i++
#endif

print(i)    // 1

#if compiler(<2.2)
    i++
#else
    i += 1
#endif

print(i)    // 2
```

### E.2 라인 제어 구문

**라인 제어 구문**은 라인 번호와 파일 이름을 소스 코드가 컴파일할 때 다른 라인 번호와 파일 이름으로 사용하도록 의도적으로 변경하고 싶을 때 사용한다. 디버깅과 진단 목적에 따라 라인 제어 구문을 사용하여 디버깅 로그에 출력할 소스 코드의 위치를 변경할 수 있다. 즉, 라인 제어 구문은 파일 이름과 라인 번호를 실제 컴파일한 파일의 환경과 다르게 변경할 수 있는 기능이다. 라인 제어 구문을 통해 #file, #line의 값을 프로그래머 마음대로 변경해주거나 초기화해줄 수 있다.

라인 제어 구문은 #sourceLocation을 사용하며, 두 가지 방법으로 사용할 수 있다.

```swift
#sourceLocation(file: 파일 이름, line: 라인 번호)
#sourceLocation()
```

먼저 #sourceLocation(file: 파일 이름, line: 라인 번호)처럼 사용하면 #file과 #line의 리터럴 표현의 값을 변경한다. 파일 이름은 문자열 값이어야 하며 라인 번호는 0이상의 정수값이어야 한다.

또는 #sourceLocation()처럼 사용하면 #sourceLocation(file: 파일 이름, line: 라인 번호)가 변경해 둔 #file과 #line의 값을 원래 파일에서의 위치대로 복원해준다. #sourceLocation(file: 파일 이름, line: 라인 번호) 구문이 선행된 이후 사용해주어야 한다.

### E.3 컴파일 시점 진단 구문

컴파일 시점 진단 구문을 사용하면 컴파일러가 컴파일하는 도중에 오류나 경고가 발생한다. 문법적으로 오류가 있어서 오류나 경고가 발생하는 것이 아니라 프로그래머가 의도적으로 오류나 경고를 발생시키고자 할 때 사용한다. 차후에 특정 위치에 코드를 작성해야 하는데 깜빡할 것 같을 때 사용하면 유용한 기능이다.

#error("오류 메시지")를 사용하면 컴파일시점에 **"오류 메시지"** 가 발생하면서 컴파일이 중단된다. #waring("경고 메시지")을 사용하면 컴파일시점에 **"경고 메시지"** 를 출력한다. 컴파일이 중단되지는 않는다. 오류 메시지나 경고 메시지에는 문자열 보간법을 사용할 수 없다.

```swift
import Swift

print("\(#file)의 \(#line)번 줄에서 실행되고 있습니다.")
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift의 3번 줄에서 실행되고 있습니다.

#sourceLocation(file: "main.swift", line: 100)
func printDebugInfo() {
    print("\(#file) 파일의 \(#line)번 줄, \(#column)번 칸이고, \(#function) 함수 안에서 실행되고 있습니다.")
}

printDebugInfo()
// main.swift 파일의 101번 줄, 50번 칸이고, printDebugInfo() 함수 안에서 실행되고 있습니다.

#sourceLocation()

print("\(#file)의 \(#line)번 줄에서 실행되고 있습니다.")
// /Users/minseok/Documents/algorithm_swift/algorithm_swift/main.swift의 16번 줄에서 실행되고 있습니다.

#warning("여기에 작성할 코드가 있을텐데요! 혹시 잊은 것이 없는지 확인해보세요!")
#error("여기에 코드 작성 안하면 오류가 발생해요!")
```

## F. 사용 가능 조건 확인

**사용 가능 조건** 을 이용하면 프로그램 실행 중 동적으로 API 사용이 가능한지 판단 할 수 있다. if, while, guard 등의 구문과 함께 사용할 수 있다.

사용 가능 조건은 기본적으로 다음과 같은 모양으로 사용할 수 있다.

```swift
if #available(플랫폼 이름 버전, *) {
    // API가 사용 가능하면 실행할 코드
} else {
    // API가 사용이 불가능하면 실행할 코드
}
```

사용 가능 조건을 통해 프로그램을 실행하는 도중에 동적으로 API 사용이 가능한지 확인하여 특정 코드를실행할 수 있도록 한다. 컴파일러는 사용 가능 조건을 통해 API를 확인하여 블록 내부의 코드를 실행할 수 있을지 판단한다.

사용 가능 조건은 플랫폼 이름과 버전의 목록 형식으로 작성한다. iOS, macOS, watchOS 등의 플랫폼 이름을 사용할 수 있으며, 버전 숫자를 포함하여 표현해준다. 에스터리스크(*) 전달인자는 모든 플랫폼을 뜻한다. 플랫폼 조건 뒤에 마지막에는 꼭 *을 붙여주어야 한다. 사용 가능 조건은 && || 등의 논리연산을 통해 조건을 추가하거나 병합할 수 없다.

```swift
if #available(iOS 11, *) {
    print("iOS 11 이상의 버전에서 실행 중입니다.")
} else if #available(iOS 10, *) {
    print("iOS 10 이상의 버전에서 실행 중입니다.")
} else {
    print("iOS 10 미만의 버전에서 실행 중입니다.")
}

if #available(iOS 11.0, macOS 10.13, *) {
    print("iOS 11.0 이상 또는 macOS의 10.13 이상의 버전에서 실행 중입니다.")
} else if #available(watchOS 4.0, *) {
    print("watchOS 4.0 이상의 버전에서 실행 중입니다.")
} else {
    print("그 외 기타 플랫폼")
}

while true {
    guard #available(iOS 9.0, *) else {
        print("iOS 9.0 미만의 버전입니다.")
        break
    }
}
```

사용 가능 조건을 실행 중에 확인할 수도 있지만, 프로그래머가 직접 함수, 메서드, 클래스, 구조체, 열거형 등에 사용 가능한 조건을 명시해줄 수도 있다. @available 표현을 사용하면 해당 코드 블록은 @available에 명시된 조건을 충족해야 사용할 수 있다. 또, 현재 빌드한 환경이 @available 속성과 맞지 않는다면 해당 코드 블록은 컴파일되지 않는다. 저장 프로퍼티에는 사용 가능 조건을 줄 수 없다. @available에 대한 자세한 설명은 속성에서 이어서 자세히 다룬다.

## G. 속성

**속성** 은 선언 또는 타입 등에 대한 부가 정보를 나타낸다. 스위프트에는 세 가지 종류의 속성이 있다. 첫 번째는 선언에 부여한는 속성이고, 두 번째는 타입에 부여하는 속성이며, 세 번째는 스위치 케이스에 부여하는 속성이다.

속성은 @ 표시를 속성 이름 앞에 명시한다. @ 표시 뒤에는 속성의 이름과 필요한 전달인자를 명시한다.

```swift
@ 속성 이름
@ 속성 이름(매개변수)
```

### G.1 선언 속성

선언 속성은 선언(클래스의 선언, 함수의 선언, 열거형의 선언, 프로토콜의 선언 등)에만 적용할 수 있다. 선언 속성 종류에는 available, discardableResult, objc, nonobjc, testable, objcMembers, dynamicMemberLookup, dynamicCallable, inlinable, usableFromInline, requires_stored_property_inits, warn_unqualified_access, propertyWrapper 등이 있다. 몇몇 선언 속성은 속성에 관한 정모를 매개변수를 통해 전달할 수 있다.

### availiable

available 속성은 특정 플랫폼 또는 운영체제의 버전에 관련된 속성이다. available 속성은 매개변수가 두 개 이상 나열되는 리스트이다. 매개변수로 사용할 수 있는 플랫폼 이름은 다음과 같다.

* iOS
* macOS
* watchOS
* tvOS
* swift
* iOSApplicationExtension
* macOSApplicationExtension
* watchOSApplicationExtension
* tvOSApplicationExtension

모든 플랫폼에 적용할 수 있도록 하라면 리스트에 애스터리스크(*)를 적어주면 된다.

나머지 매개변수는 추가 정보를 나타내는데 쓰인다. 중요한 남김말이나 생명주기 등의 자세한 정보를 나타낼 수 있다. 그런 정보들을 나타낼 때 쓰이는 매개변수의 이름에는 unavailable, introduced, deprecated, obsoleted, message, renamed가 있다.

#### unavailable

unavailable 매개변수는 해당 플랫폼에서 사용할 수 없는 선언임을 나타낸다.

```swift
@available(tvOS, unavailable)
class SomeClass()
// tvOS에서 사용할 수 없는 클래스입니다.
```

#### introduced

introduced 매개변수는 이 선언이 어떤 버전에서 처음으로 소개(작성)되었는지 나타낸다. 콜론(:) 뒤에 버전 번호를 덧붙여준다. 버전 번호는 양수로 나타낸다.

```swift
class SomeClass() {
    // 이 프로퍼티는 스위프트 4.0에서 작성했으므로
    // 스위프트 4.0 이상에서만 사용할 수 있다.
    @available(swift, introduced: 4.0)
    var multilineString: String {
        return """
        여러 줄
        문자열은
        스위프트 4.0 이상에서
        사용할 수 있습니다
        """
    }
}
```

#### deprecated

deprecated 매개변수는 이 선언이 어떤 버전에서 사용이 제한(중지)되었는지 나타낸다. 특별히 버전을 명시하고 싶지 않다면 뒤에 콜론과 버전을 생략해도 된다.

```swift
@available (*, deprecated: 2.0.0)
class SomeClass { }
// 이 클래스는 2.0.0 버전부터 사용이 제한되었습니다.
```

#### obsoleted

obsoleted 매개변수는 이 선언이 어떤 버전부터 버려진 것인지 나타낸다. 버려진 선언은 더이상 사용할 수 없다.

```swift
@available (*, obsoleted: 2.0.0)
class SomeClass { }
// 이 클래스는 2.0.0 버전부터 사용이 불가능합니다.
```

#### message

message 매게변수는 사용이 제한되거나 불가능한 선언을 사용하려고 할 때 컴파일러로 프로그래머에게 전달할 경고 또는 오류 메시지이다. 메시지는 문자열 리터럴로 작성한다.

```swift
@available(*, depercated: 2.0.0, message: "아마도 쓰지 않을 것이 좋을 걸?")
class SomeClass { }
// 이 클래스는 2.0.0 버전부터 사용이 제한되었습니다.

let instance = SomeClass()  // 플랫폼 보전이 기준 버전보다 높다면 컴파일러 경고
```

#### renamed

renamed 매개변수는 해당 선언이 교체되어 다른 이름으로 변경되었을 때, 그 다른 이름을 나타낸다. 다른 이름으로 교체된 선언을 사요하려 할 때 컴파일러를 통해 프로그래머에게 다른 클래스를 사용할 것을 제안할 경고 또는 오류 메시지이다. 메시지는 문자열 리터럴로 작성한다.

```swift
@available(*, deprecated: 2.0.0, message: "아마도 쓰지 않을 것이 좋을 걸?", renamed: "NewClass")
class SomeClass { }
// 이 클래스는 2.0.0 버전부터 사용이 제한되었습니다.


@available(*, unavailable, message: "사용 불가", renamed: "NewClass")
class AnotherClass { }
// 이 클래스는 사용 불가능합니다.

@available(*, introduced: 2.0.0)
class NewClass { }

let someInstance = SomeClass()          // 플랫폼 버전이 기준 버전보다 높다면 컴파일러 경고
let anotherInstance = AnotherClass()    // 컴파일러 오류
let newInstance = NewClass()            // 플랫폼 버전이 기준 버전보다 낮다면 컴파일러 오류
```

available 속성의 매개변수로 여러 플랫폼과 여러 매개변수를 동시에 전달할 수 있다. 또, introduced 매개변수를 생략하고 곧바로 버전을 명시해줄 수도 있다. 몇 가지 플랫폼에서 사용할 것을 한정할 때는 사용하고 싶은 플랫폼 이름과 최소 버전을 명시해주면 된다. 그리고 리스트의 맨 마지막은 꼭 애스터리스크로 끝나야 한다.

```swift
@available(iOS 11.0, *)
func someFunction() { }

@available(iOS 11.0, macOS 10.13, watchOS 4.0, *)
func anotherFunction() { }
```

### discardableResult

흔히 반환 값이 있는 함수나 메서드를 호출한 후 반환 값을 다른 변수나 상수에 할당하여 사용하거나 조건 수식에 반영하는 등 반환 값이 있는 함수의 반환 값은 유의미하게 사용되는 경우가 많다.

그렇지만 종종 반환 값을 유의미하게 사용하지 않고 버려도 되는 함수들이 있다. 이때 컴파일러 경고가 발생하지 않도록 하려면 discardableResult 속성을 함수나 메서드의 정의에 부여하면 된다.

### objc

스위프트로 선언된 코드를 Objective-C의 코드에서 표현하고 사용할 수 있도록 하려면 objc 속성을 사용한다. 단, 중첩 타입, 제네릭 열거형 등은 objc 속성을 사용할 수 없다

objc 속성이 부여된 클래스는 Objective-C의 클래스를 꼭 상속받아야 한다. objc 속성이 부여된 클래스를 상속받는 클래스는 암시적으로 objc 속성이 부여된다. objc 속성이 부여된 프로토콜은 objc 속성이 부여되지 않은 스위프트의 프로토콜을 상속받을 수 없다. objc 속성이 부여된 프로토콜을 상속받는 프로토콜은 암시적으로 objc 속성이 부여된다.

```swift
import Foundation

// 오류 - Objective-C의 클래스를 상속받지 않았습니다.
@objc
class SomeClass { }

// Objective-C의 클래스를 상속받으면 암시적으로 @objc 속성이 부여된다.
class AnotherClass: NSObject { }

protocol ParentProtocol { }

@objc   // 오류 - ParentProtocol은 objc 속성이 없다.
protocol SomeProtocol: ParentProtocol { }
```

objc 속성이 부여된 열거형은 Objective-C 코드에서 사용할 수 있다. 다만 원시 값 타입을 Int 타입으로 지정해야주어야 한다. 스위프트로 작성한 각 열거형 case의 이름은 Objective-C 코드에서는 Objective-C 스타일의 열거형 case 이름으로 나타낸다. 예를들어 스위프트의 Planet 열거형 earth 케이스는 Objective-C 코드에서 PlanetEarth라는 이름으로 나타난다.

```swift
@objc
enum Planet: Int {
    case mercury, venus, earth, mars, jupiter
    // Objective-C 이름
    // PlanetMercury, PlanetVenes, PlanetEarth, PlanetMars, PlanetJupiter
}
```

스위프트와 Objective-C의 명명 규칙이 다르기 때문에 배려해야 하는 부분도 있다. 그래서 자동으로 변경되지 않는 이름은 수동으로 이름을 정해줘야 할 때도 있다. objc 속성을 부여할 때 매개변수로 이름을 전달하면 해당 선언이 Objective-C 코드에서는 매개변수로 전달한 이름으로 사용한다. 다른 이름으로 변경할 수 있는 선언은 클래스, 열거형, 열거형 case, 프로토콜, 메서드, 접근자, 설정자, 이니셜라이저 등이 있다.

```swift
import Foundation

@objc(Example)
// Objective-C 코드에서는 ExampleClass 클래스 이름이 Example이라고 보인다.
class ExampleClass: NSObject {
    @objc var enable: Bool {
        // Objective-C 코드에서는 enable 프로퍼티의 이름이 isEnabled 라고 보인다.
        @objc(isEnable) get {
            return true
        }
    }
    
    // Objective-C 코드에서는 print(name: ) 메서드의 이름이 printWithName: 이라고 보인다.
    @objc(printWithName:)
    func print(name: String) {      }
    
    // Objective-C 코드에서는 init(name: ) 이니셜라이저의 이름이 initWithName: 이라고 보인다.
    @objc(initWithName:)
    init(name: String) {    }
}
```

### nonobjc

메서드, 프로퍼티, 서브스크립트, 이니셜라이저, 디이니셜라이저 등에 nonobjc 속성을 부여하면 Objective-C 코드에서는 사용이 불가능하다. 또, nonobjc 속성을 부여한 메서드는 objc 속성이 부여된 메서드로 재정의할 수 없으며, objc 속성을 요구하는 프로토콜 요구사항을 충족할 수 없다.

### testable

testable 속성은 테스트를 위해 컴파일한 모듈에 정의한 내부 접근수준 정의를 공개 접근수준으로 정의한 것처럼 만들어준다. 외부에서 가져다 테스트할 수 있도록 부여할 수 있는 속성이다. 테스트를 위한 코드는 공개 접근수준과 내부 접근수준으로 testable 속성과 함께 정의한 클래스나 클래스 요소에 개방 접근수준의 접근수준처럼 접근하여 테스트할 수 있다.

### objcMembers

클래스 선언에 objcMembers 속성을 적용하면 클래스에 objc 속성을 부여할 수 있다. objc 속성은 클래스의 멤버, 클래스의 익스텐션, 자식클래스를 비롯한 하위클래스 및 익스텐션에도 암묵적으로 Objective-C와 호환되도록 한다.

대부분의 경우 objc 속성을 사용할 테지만, 정의 하나만 Objective-C에 노출하려는 경우에는 objcMembers 속성을 사용한다. 많은 양의 정의를 노출하고자 한다면 익스텐션에 그 정의룰 묶어 objc 속성을 주는 것이 좋다. 불필요한 곳에 objc 속성을 남용하면 바이너리의 크기가 커질 뿐만 아니라 성능에 영향을 미칠 수도 있다. 클래스나 라이브러리의 크기가 클 때 모든 멤버가 Objective-C 멤버로 노출될 필요가 없다면 objcMembers 속성을 사용하여 필요한 멤버만 노출하도록 한다.

### dynamicMemberLookup
클래스, 구조체, 열거형, 프로토콜 선언에 이 속성을 적용하면 실행중에 이름으로 멤버(프로퍼티 등)를 찾을 수 있다. 이 속성을 적용한 타입은 subscript(dynamicMemberLookup:)서브스크립트를 정의해야 한다.

이 속성을 적용한 타입의 인스턴스에 명확한 멤버 표현(예를 들어 점 표기법 등)에서 적절한 멤버를 찾지 못하면 서브스크립트에 매개변수로 그 멤버의 이름이 전달한 subscript(dynamicMemberLookup:) 서브스크립트가 호출된다. 서브스크립트의 매개변수는 키경로 혹은 멤버 이름을 모두 수용할 수 있다. dynamicMemberLookup 속성을 적용한 클래스를 상속받으면 상속받은 클래스도 dynamicMemberLookup 속성이 적용된다.

subscript(dynamicMemberLookup:) 서브스크립트를 구현할 때 KeyPath, WritableKeyPath, ReferenceWritableKeyPath 등의 타입을 매개변수로 전달받을 수 있다. 또, 멤버 이름을 ExpressibleByStringLiteral 프로토콜을 준수하는 타입의 매개변수로 전달받을 수도 있다.

멤버의 이름으로 멤버를 찾는 것은 실행중에 데이터가 존재할지 확신할 수 없는 상황에서 사용하기 좋다.

```swift
@dynamicMemberLookup
struct Contacts {
    private let contacts: [String: String] = ["minseok": "010-4111-7631",
                                              "hana": "010-5544-5568"]
    subscript(dynamicMember member: String) -> String {
        return contacts[member] ?? "114"
    }
}

let contacts: Contacts = Contacts()

// Dynamic Member Lookup 사용
let hanas: String = contacts.hana
print(hanas)    // 010-5544-5568

// 서브스크립트 직접 호출
let minseok: String = contacts[dynamicMember: "minseok"]
print(minseok)  // 010-4111-7631

// 찾을 수 없는 경우
let somebody: String = contacts.somebody
print(somebody) // 114

let anybody: String = contacts[dynamicMember: "anybody"]
print(anybody)  // 114
```

### dynamicCallable

클래스, 구조체, 열거형, 프로토콜 등의 선언에 dynamicCallable 속성을 적용하면 그 타입의 인스턴스 자체를 함수처럼 호출할 수 있다. 이 속성을 적용한 타입에는 dynamicallyCall(withKeywordArguments:) 메서드를 구현해야 한다. 물론 두 메서드 모두 다 구현해도 무관하다.

dynamicallyCall(withKeywordArguments:) 메서드는 다음 코드처럼 ExpressibleByArrayLiteral 프로토콜을 준수하는 단 하나의 매개변수만 받을 수 있다. 반환 타입은 어떤 타입이든 상관 없다. 만약에 메서드를 호출할 때 매개변수 레이블을 사용하고 싶다면 dynamicallyCall(withKeywordArguments:) 메서드를 활용하면 된다.

```swift
@dynamicCallable
struct Contacts {
    private let contacts: [String: String] = ["minseok": "010-4111-7631",
                                              "hana": "010-5544-5568"]
    func dynamicallyCall(withArguments names: [String]) -> [String] {
        var result: [String] = []
        for name in names {
            guard let mobile: String = contacts[name] else {
                continue
            }
            result.append(mobile)
        }
        return result
    }
}

let contacts: Contacts = Contacts()
var mobiles: [String]

// Dynamic Member Lookup 사용
mobiles = contacts("minseok", "hana")
print(mobiles)  // ["010-4111-7631", "010-5544-5568"]
mobiles = contacts("you", "minseok", "me")
print(mobiles)  // ["010-4111-7631"]

@dynamicCallable
struct Repeater {
    func dynamicallyCall(withKeywordArguments pairs: KeyValuePairs<String, Int>) -> String {
        return pairs.map {
            label, count in
            repeatElement(label, count: count).joined(separator: " ")
        }
        .joined(separator: "\n")
    }
}

let repeatLabels: Repeater = Repeater()
print(repeatLabels(minseok: 1, hana: 2))
// minseok
// hana hana
```

### inlinable

inlinable 속성을 함수, 메서드, 연산 프로퍼티, 서브스크립트, 편의 이니셜라이저, 디이니셜라이저 등의 선언에 적용하면 모듈의 공개 인터페이스의 일부로 노출된다. 컴파일시에 컴파일러는 inlinable 속성을가진 함수, 메서드, 연산 프로퍼티, 서브스크립트, 편의 이니셜라이저, 디이니셜라이저 등을 호출하는 코드 부분에서 단순히 호출하도록 컴파일하는 것이 아니라 inlinable 구현코드를 그대로 치환한다.

inlinable 코드는 다른 모듈이나 같은 모듈의 공개(public) 접근수준의 코드와 상호작용 할 수 있다. 또, 같은 모듈의 내부 (internal) 접근수준에 usableFromInline 속성을 적용한 코드와 상호작용 할 수 있다. 비공개(private) 혹은 파일외부비공개(fileprivate) 접근 수준의 코드와는 상호작용 할 수 없다.

inlinable 속성은 비공개(private) 혹은 파일외부비공개(fileprivate) 접근수준의 선언부 혹은 중첩 함수 내부에는 적용할 수 없다. inlinable 속성을 적용한 코드 내부에 선언한 함수나 클로저는 암시적으로 inlinable 속성이 적용된다.

### usableFromInline

usableFromInline 속성을 함수, 메서드, 연산 프로퍼티, 서브스크립트, 편의 이니셜라이저, 디이니셜라이저 등의 선언에 적용하면 같은 묘듈의 inlinable 코드와 상호작용할 수 있다. usableFromInline 속성을 적용한 선언은 내부(internal) 접근 수준의 코드여야 한다.

usableFromInline 속성을 적용하면 모듈의 공개 인터페이스의 일부로써 선언이 노출된다. inlinable 속성을 적용한 선언은 usableFromInline 속성을 암시적으로 적용한 것으로 취급한다. 하나의 선언에 inlinable 속성과 usableFromInline 속성을 동시에 적용할 수 없다.

### requires_stored_property_inits

클래스의 선언에 requires_stored_property_inits 속성을 적용하면 그 클래스의 모든 저장 프로퍼티가 기본값이 있어야 한다. 모든 저장프로퍼티의 값을 초기화해주는 지정 이니셜라이저가 있다고 하더라도 초깃값이 있어야 한다. NSManagedObject 클래스를 상속받은 클래스는 기본적으로 이 속성을 적용한 것으로 취급한다.

### warn_unqualified_access

최상위 수준의 함수, 인스턴스 메서드, 클래스 메서드, 정적 메서드에 warn_unqualified_access 속성을 적용하면 (모듈 이름, 타입 이름, 인스턴스 변수, 인스턴스 상수 등의) 선확인자 없이 사용할 때 경고가 발생한다. 같은 범위에 같은 이름의 함수나 메서드 등이 존재하는 경우 컴파일러가 어떤 것을 실행해야 할지 애매할 수 있다. 이런 애매함이 발생하지 않도록 미연에 방지할 수 있다.

예를 들어 스위프트 표준 라이브러리에 min(_ : _ :) 함수가 있는데, 시퀀스를 갖는 Sequence 타입에도 같은 이름의 min() 메서드가 있다. 사용의 혼동을 막조가 Sequence 타입의 메서등에는 warn_unqualified_access 속성이 적용되어 있다.

### propertyWrapper

클래스, 구조체, 열거형 선언에 이 속성을 적용하면 프로퍼티의 접근 패턴을 정의하는 타입이 된다. 프로퍼티의 선언에서 propertyWrapper 속성을 적용한 타입을 채택하면 그 타입에서 구현한 접근 패턴을 활용할 수 있다.

propertyWrapper 속성을 적용한 타입은 wrappedValue라는 이름의 프로퍼티를 구현해야한다. 또한 특정 매개변수를 갖는 이니셜라이저를 구현하여 프로퍼티 선언부에 이니셜라이저를 통한 프로퍼티 사용에 필요한 최소 설정을 할 수 있다.

특정 타입의 프로퍼티의 값을 파일에 읽고 쓰는 경우나 UserDefaults 등에서 읽고 쓰는 경우 등, 프로퍼티의 접근과 할당이 특정 패턴을 갖는 경우 매우 유용하게 사용할 수 있다. 다양한 경우에 활용할 수 있는 만큼 예제 코드를 통해 간단히 살펴보겠다. 다음 코드는 propertyWrapper의 간단한 활용방법을 알아보자.

```swift
import Foundation

// 프로퍼티를 텍스트 파일로 읽고 쓰도록 포장할 때 사용할 패턴입니다.
@propertyWrapper
struct TextFileIO {
    
    private var fileLocation: URL
    
    init(fileName: String?) {
        let applicationSupportDirectory: URL
        
        do {
            applicationSupportDirectory = try FileManager.default.url(for: .applicationDirectory, in: .userDomainMask, appropriateFor: nil, create: false)
        } catch {
            fatalError("파일경로 생성 실패")
        }
        
        let fileNameToAppend: String
        
        if let fileName = fileName {
            fileNameToAppend = fileName
        } else {
            fileNameToAppend = "file.text"
        }
        
        self.fileLocation = applicationSupportDirectory.appendingPathComponent(fileNameToAppend)
    }
    
    var wrappedValue: String {
        get {
            guard let string = try? String(contentsOf: self.fileLocation, encoding: String.Encoding.utf8) else {
                return ""
            }
            return string
        }
        
        set {
            try? newValue.write(to: self.fileLocation, atomically: true, encoding: String.Encoding.utf8)
        }
    }
}

// TextFileIO 패턴을 적용한 프로퍼티를 사용하는 NoteManager 구조체
struct NoteManager {
    @TextFileIO(fileName: "title.text")
    var title: String
    
    @TextFileIO(fileName: "contents.txt")
    var contents: String
}

var manager = NoteManager()
print(manager.title)    // 다음 실행에서 지난 번 변경 내용이 저장되어 있었는지 확인해봅니다.
manager.title = "title" // 새로운 제목을 파일에 저장합니다.

print(manager.contents) // 다음 실행에서 지난 번 변경 내용이 저장되어 있었는지 확인해봅니다.
manager.contents = "minseok"    // 새로운 내용을 파일에 저장합니다.

// 특정 프로퍼티에 할당하는 값이 범위를 벗어나지 않도록 제한하는 패턴을 만들어봅시다.
@propertyWrapper
struct LimitedRange<T: Comparable> {
    
    var value: T
    let range: ClosedRange<T>
    
    init(initialValue: T, range: ClosedRange<T>) {
        precondition(range.contains(initialValue))
        self.value = initialValue
        self.range = range
    }
    
    var wrappedValue: T {
        get {
            return self.value
        }
        mutating set {
            value = max(min(range.upperBound, newValue), range.lowerBound)
        }
    }
}

// LimitedRange 패턴을 적용한 프로퍼티를 활용해봅시다.
struct Person {
    let name: String
    @LimitedRange(range: 0...150) var age: Int = 0
    
}

var minseok: Person = Person(name: "minseok", age: 100)
print(minseok.age)      // 100
minseok.age = -1
print(minseok.age)      // 0
minseok.age = 160
print(minseok.age)      // 150
```

### G.2 타입 속성

타입 속성은 타입에만 적용할 수 있다. 종류에는 autoclosure, convention, escaping이 있다.

#### autoclosure

autoclosure 속성을 부여한 매개변수에 작성된 표현을 바로 실행하지 않고 전달인자가 없는 클로저로 변경하고자 할 때 사용한다. 함수나 메서드의 매개변수 타입의 속성으로 사용할 수 있다.

#### convention

convention 속성은 함수의 타입이 어떤 호출 방식을 사용할지 지정하며 swift, block, c 중 하나의 매개변수를 갖는다.

swift 매개변수는 스위프트 함수 참조를 나타낸다. 스위프트의 함수 값을 위한 표준 호출 방식이다.

block 매개변수는 Objective-C 블록 객체 참조를 나타낸다. Objective-C의 블록 객체는 C 언어 함수 호출 방식을 포함한다.

C 매개변수는 C 언어의 함수의 참조를 나타낸다. C 언어 함수 호출 방식이다.

C 언어 함수 호출 방식은 Objective-C 블록 호출 방식으로 사용할 수 있고, Objective-C 블록 호출 방식은 스위프트 함수 호출 방식으로 사용할 수 있다. 그러나 지역변수를 획득하지 않고 제네릭을 사용하지 않은 전역함수, 제네릭을 사용하지 않은 지역함수, 제네릭을 사용하지 않은 클로저는 C 언어 함수 호출 방식으로 사용할 수 있다.

```swift
import Foundation

// 전역변수
var someGlobalInstance: NSObject = NSObject()

func switfParamFunction(_ param: @convention(swift) () -> Void) { param() }

func blockParamFunction(_ param: @convention(block) () -> Void) { param() }

func cParamFunction(_ param: @convention(c) () -> Void) { param() }

switfParamFunction{ [someGlobalInstance] in print(someGlobalInstance) }
blockParamFunction{ [someGlobalInstance] in print(someGlobalInstance) }

// 오류: 전역변수를 획득하는 클로저는 C 언어 함수 호출 방식으로 사용할 수 없다.
cblockParamFunction{ [someGlobalInstance] in print(someGlobalInstance) }

let someSwiftClosure: @convention(swift) () -> Void = {
    [someGlobalInstance] in print(someGlobalInstance)
}

let someblock: @convention(block) () -> Void = {
    [someGlobalInstance] in print(someGlobalInstance)
}

// 오류: 전역변수를 획득하는 클로저는 C 언어 함수 호출 방식으로 사용할 수 없다.

let someCFunction: @convention(c) () -> Void = {
    [someGlobalInstance] in print(someGlobalInstance)
}
```

#### escaping

메서드나 함수의 매개변수 타입에 escaping 속성을 사용하면 매개변수의 값을 나중에 실행하기 위해서 어딘가로 다시 저장될 가능성이 있다는 것을 의미한다. 즉, 함수나 메서드의 호출이 끝난 후에도 매개변수를 사용할 수 있다는 것을 의미한다. escaping에 대한 자세한 설명과 예는 탈출 클로저에 있다.

### G.3 스위치 케이스 속성

스위치 케이스 속성은 스위치의 케이스 선언에 적용할 수 있는 속성이다. unknown 속성이 있다.

#### unknown

스위치 케이스에 unknown 속성을 적용하면 열거형의 각 케이스가 스위치 구문의 각 케이스에 매칭되지 않는 경우 컴파일 경고를 발생시킨다.

## H. 타입 별칭 및 호환 타입

스위프트에서 많이 사용하는 타입이지만 실제로는 타입 별칭인 경우가 많다. 또, C 언어 등과 타입을 호환히가 위해 별칭으로 사용하는 타입들이 있다. 그런 타입들이 실제로는 스위프트의 어떤 타입인지 알아보자.

|별칭|실제 타입|설명|
|---|---|---|
|AnyClass|AnyObject.Type|모든 클래스 타입이 암시적으로 준수하는 프로토콜|
|BooleanLiteralType|Bool|Boolean 리터럴의 기본 타입
|CBool|Bool|C의 _Bool 및 C++의 bool 타입|
|CChar|Int8|C의 char 타입 플랫폼에 따라 CSignedChar 또는 CUnsignedChar 타입과 같다|
|CChar16|UInt16|UTF-16 인코딩을 사용하는 C++11의 char16_t 타입|
|CChar32|Unicode Scalar|UTF-32 인코딩을 사용하는 C++11의 char32_t 타입
|CDouble|Double|C의 double 타입|
|CFloat|Float|C의 float 타입|
|CInt|Int32|C의 int 타입|
|CLong|Int|C의 long 타입|
|CLongLong|Int64|C의 long long 타입|
|Codable|Decodable & Encodable|다른 형식으로 저장하거나 불러오는 작업을 스스로 처리할 수 있는 타입|
|CShort|Int16|C의 short 타입|
|CSignedChar|Int8|C의 signed char 타입|
|CUnsignedChar|UInt8|C의 unsigned char 타입|
|CUnsignedInt|UInt32|C의 unsigned int 타입|
|CUnsignedLong|UInt|C의 unsigned long 타입|
|CUnsignedLongLong|UInt64|C의 unsigned long long 타입|
|CUnsignedShort|UInt16|C의 unsigned short 타입|
|CWideChar|Unicode Scalar|C++의 wchar_t 타입|
|ExtendedGraphemeClusterType|String|유니코드로 확장된 문자 집합 리터럴의 기본 타입|
|Float32|Float|32비트 부동소수 타입|
|Float64|Double|64비트 부동소수 타입
|FloatLiteralType|Double|부동소수 리터럴의 기본 타입
|IntegerLiteralType|Int|정수 리터럴의 기본타입|
|StringLiteralType|String|문자열 리터럴의 기본타입|
|UnicodeScalarType|String|유니코드 스칼라 리터럴의 기본 타입|
|Void|()|빈 튜플 타입, Void, 즉 빈 튜플은 함수의 반환 타입을 명시하지 않으면 암시적으로 사용되는 반환 타입이다.

