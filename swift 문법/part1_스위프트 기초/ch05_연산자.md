# 5. 연산자

스위프트의 연산자는 특정한 문자로 표현한 함수라 할 수 있다. 따라서 특정 연산자의 역할을 프로그래머의 의도대로 변경할 수 있다.

연산자에 의해 연산 되는 값의 수에 따라 단항, 이항, 삼항 등으로 구분하기도 하며, 연산자의 위치에 따라 전위, 중위, 후위 등으로 구분하기도 한다.

|분류|설명|예|
|---|---|---|
|단항 연산자|피연산자(연산 대상)가 한개인 연산자|!A
|이항 연산자|피연산자가 두 개인 연산자|A + B
|삼항 연산자|피연산자가 세 개인 연산자|A ? B : C
|전위 연산자|연산자가 피연산자 앞에 위치하는 연산자|!A
|중위 연산자|연산자가 피연산자 사이에 위치하는 연산자|A + B
|후위 연산자|연산자가 피연산자 뒤에 위치하는 연산자|A!

이번 장에서는 간단한 예를 들어 연산자를 설명하려 한다. 좀 더 자세한 활용법은 이후 장에서 나오는 코드에서 직접 볼 수 있다. 스위프트에서 추가된 개념이거나 독특한 특성이 있는 연산자는 좀 더 자세히 설명해두었다.

## 5.1 연산자의 종류
연산자는 종류가 굉장히 많다. 먼저 몇 가지 주요 연산자를 하나씩 설명한다.

### 5.1.1 할당 연산자
값을 할당할 때 사용하는 연산자이다.

|연산자|부호|설명|
|---|---|---|
|할당(대입) 연산자|A = B|A에 B의 값을 할당한다. 서로 다른 데이터 타입이면 오류가 발생한다.|

### 5.1.2 산술 연산자
산술 연산자는 대체로 수학에서 쓰이는 연산자와 같은 역할을 수행한다.
|연산자|부호|설명|
|---|---|---|
|더하기 연산자|A + B|A와 B를 더한 값을 반환한다.
|빼기 연산자|A - B|A에서 B를 뺀 값을 반환한다.
|곱하기 연산자|A * B|A에서 B를 곱한 값을 반환한다.
|나누기 연산자|A / B|A를 B로 나눈 값을 반환한다.
|나머지 연산자|A % B|A를 B로 나눈 나머지를 반환한다.

**NOTE_스위프트의 나머지 연산과 나누기 연산자**

스위프트에서는 부동소수점 타입의 나머지 연산까지 지원한다. 기존의 프로그래밍 언어에서는 나머지 연산자가 정수 타입만 지원하는 경우가 많았는데 스위프트에서는 부동소수점 타입도 나머지 연산을 할 수 있다.

```swift
let number: Double = 5.0
var result: Double = number.truncatingRemainder(dividingBy: 1.5) // 0.5
result = 12.truncatingRemainder(dividingBy: 2.5)                 // 2.0
```

나누기 연산은 기존의 프로그래밍 언어처럼 나머지나 소수점을 제외한 정수만을 결과값으로 반환한다.

```swift
var result: Int = 5 / 3     // 1
result = 10 / 3             // 3
```

또한, 스위프트는 데이터 타입에 굉장히 엄격하므로 서로 다른 자료형끼리의 연산을 엄격히 제한한다. 서로 다른 자료형끼리의 연산을 실행하려면 값을 해당 타입으로 변환한 후 연산해야 한다.

### 5.1.3 비교 연산자
두 값을 비교할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|값이 같다.| A == B|A와 B가 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 크거나 같다.| A >= B|A가 B보다 크거나 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 작거나 같다.| A <= B|A가 B보다 작거나 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 크다.| A > B|A가 B보다 큰 값인지 비교하여 불리언 값을 반환한다.
|값이 작다.| A < B|A가 B보다 작은 값인지 비교하여 불리언 값을 반환한다.
|값이 같지 않다.| A != B |A와 B가 다른 값인지 비교하여 불리언 값을 반환한다.
|참조가 같다|A === B|A와 B가 참조(레퍼런스) 타입일 때 A와 B가 같은 인스턴스를 가리키는 비교하여 불리언 값을 반환한다.
|참조가 같지 않다.|A !== B|A와 B가 참조(레퍼런스) 타입일 때 A와 B가 같지 않은 인스턴스를 가리키는지 비교하여 불리언 값을 반환한다.
|패턴 매치|A ~= B|A와 B의 패턴이 매치되는지 확인하여 불리언 값을 반환한다.

**NOTE_참조 비교 연산자**

스위프트의 유일한 참조타입인 클래스의 인스턴스에서만 참조 비교 연산자를 사용할 수 있다. 스위프트의 기본 데이터 타입은 모두 구조체로 구현되어 있기 때문에 값 타입이다. 그렇기 때문에 값의 비교 연산에는 ==를 사용하고 클래스의 인스턴스인 경우에만 ===를 사용한다. 구조체와 클래스, 값 타입과 참조 타입에 대해서는 값 타입과 참조 타입에서 더 자세히 알아본다.

```swift
let valueA: Int = 3
let valueB: Int = 5
let valueC: Int = 5

let isSameValueAB: Bool = valueA == valueB      // false
let isSameValueBC: Bool = valueB == valueC      // true

let referenceA: SomeClass = SomeClass()
let referenceB: SomeClass = SomeClass()
let referenceC: SomeClass = referenceA

let isSameReferenceAB: Bool = referenceA === referenceB     // false
let isSameReferenceAC: Bool = referenceA === referenceC     // true
```

### 5.1.4 삼항 조건 연산자
피연산자가 세 개인 삼항 조건 연산자이다.
|연산자|부호|설명|
|---|---|---|
|삼항 조건 연산자|Question ? A : B|Question(불리언 값)이 참이면 A, 거짓이면 B를 반환한다.

삼항 조건 연산자를 사용하면 조건식을 간단히 한 줄에 표현할 수 있다.

```swift
var valueA: Int = 3
var valueB: Int = 5
var biggerValue: Int = valueA > valueB ? valueA : valueB    // 5

valueA = 0
valueB = -3
biggerValue = valueA > valueB ? valueA : valueB             // 0

var stringA: String = ""
var stringB: String = "String"
var resultValue: Double = stringA.isEmpty ? 1.0 : 0.0       // 1.0
resultValue = stringB.isEmpty ? 1.0 : 0.0                   // 0.0
```

물론, 조건 안에 또 다른 삼항 연산자를 넣을 수도 있고, 여러번 중첩할 수도 잇지만, 중첩을 너무 많이 사용하면 오히려 코드를 이해하기 어려우므로 적절히 사용할 줄 아는 지혜가 필요하다.

### 5.1.5 범위 연산자
값(수)의 범위를 나타내고자 할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|폐쇄 범위 연산자|A...B|A부터 B까지의 수를 묶어 범위를 표현한다. A와 B를 포함한다.
|반폐쇄 범위 연산자|A..<B|A부터 B미만까지의 수를 묶어 범위를 표현한다. A를 포함하고, B를 포함하지 않는다.
|단방향 범위 연산자|A.. |A 이상의 수를 묶어 범위를 표현한다. A를 포함한다.
||...A|A 이하의 수를 묶어 범위를 표현한다. A를 포함한다.
||..<A|A 미만의 수를 묶어 범위를 표현한다. A를 포함하지 않는다.

### 5.1.6 부울 연산자
불리언 값의 논리 연산을 할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|NOT(부정) 부울 연산자|!B|B(불리언 값)의 참, 거짓을 반전한다.
|AND 부울 연산자| A && B | A와 B의 불리언 AND 논리 연산을 실행한다.
|OR 부울 연산자| A \|\| B |A와 B의 불리언 OR 논리연산을 실행한다.

### 5.1.7 비트 연산자
값의 비트 논리 연산을 위한 연산자이다.

|연산자|부호|설명|
|---|---|---|
|NOT(부정) 비트 연산자|~A|A의 비트를 반전한 결과를 반환한다.
|AND 비트 연산자|A & B|A와 B의 비트 AND 논리 연산을 실행한다.
|OR 비트 연산자| A \| B|A와 B의 OR 논리 연산을 실행한다.
|XOR 비트 연산자| A^B |A와 B의 비트 XOR 논리 연산을 실행한다.
|비트 이동 연산자(시프트연산자)|A >> B, A << B|A의 비트를 B만큼 비트를 시프트(이동)한다.

시프트 연산자는 지정하는 수만큼 피연산자를 왼쪽(<<) 또는 오른쪽(>>)으로 이동한다. 예를 들어 정수 4(0100)을 왼쪽으로 1 시프트 연산할때 4 << 1 로 표현해줄 수 있다. 왼쪽으로 비트를 이동했기 때문에 결과는 8(1000)이 된다. 반대로 오른쪽 1 시프트 연산을 하면 4 >> 1 로 표현할 수 있고 결과는 2(0010)가 된다.

위의 왼쪽 비트 연산의 결과처럼 시프트 한 후 빈 자리는 0으로 채워진다. 반대로 시프트 연산을 하면서 비트 범위를 벗어난 비트는 버려진다. 만약 7(0111)을 오른쪽 2 시프트 연산을 하면, 결과는 1(0001)이 된다.

### 5.1.8 복합 할당 연산자
할당 연산자와 다른 연산자가 하는 일을 한 번에 할 수 있도록 연산자를 결합할 수 있다. 이를 복합 할당 연산자라고 한다.
|표현|설명|같은 표현|
|---|---|---|
|A += B|A와 B의 합을 A에 할당한다.|A = A + B
|A -= B|A와 B의 차를 A에 할당한다.|A = A - B
|A *= B|A와 B의 곱을 A에 할당한다.|A = A * B
|A /= B|A를 B로 나눈 값을 A에 할당한다.|A = A / B
|A %= B|A를 B로 나눈 나머지를 A에 할당한다.|A = A % B
|A <<= N|A를 N만큼 왼쪽 비트 시프트 한 값을 A에 할당한다.|A = A << N
|A >>= N|A를 N만큼 오른쪽 비트 시프트 한 값을 A에 할당한다.|A = A >> N
|A &= B|A와 B의 비트 AND 연산 결과를 A에 할당한다.|A = A & B
|A \|= B|A와 B의 비트 OR 연산 결과를 A에 할당한다.|A = A \| B
|A ^= B|A와 B의 비트 XOR 연산 결과를 A에 할당한다.|A = A ^ B

### 5.1.9 오버플로 연산자
기존 프로그래밍 언어에서는 오버플로(또는 언더플로) 가능성이 있는 연산에 대해서는 따로 오버플로에 대한 추가 알고리즘 및 로직 등을 설계하는 것이 일반적이었다. 스위프트는 기본 연산자를 통해 오버플로에 대비할 수 있도록 준비해두었다. 오버플로 연산자를 사용하면 오버플로를 자동으로 처리한다.

|연산자|부호|설명|
|---|---|---|
|오버플로 더하기 연산|&+|오버플로에 대비한 덧셈 연산을 한다.
|오버플로 뺴기 연산|&-|오버플로에 대비한 뺄셈 연산을 한다.
|오버플로 곱하기 연산|&*|오버플로에 대비한 곱셈 연산을 한다.

예를 들어 UInt8 타입은 8비트 정수 타입으로 부호가 없는 양의 정수만을 표현하기 때문에 0 아래로 내려가는 계산을 하면 런타임 오류가 발생한다. 그렇지만 오버플로 빼기 연산을 사용하면 오류 없이 오버플로 처리를 해준다. 그렇지만 오버플로에 대한 이해 없이 사용한다면 엉뚱한 값을 구할 수도 있다. 따라서 오버플로에 대해 먼저 이해하고 사용해야 한다.

```swift
var unsignedInterger: UInt8 = 0
let errorUnderflowResult: UInt8 = unsignedInterger - 1      // 런타임 오류
let underflowedValue: UInt8 = unsignedInterger &- 1         // 255

unsignedInterger = UInt8.max
let errorOverflowResult: UInt8 = unsignedInterger + 1       // 런타임 오류
let overflowedValue: UInt8 = unsignedInterger + 1           // 0
```

### 5.1.10 기타 연산자
앞서 소개한 연산자 외에 스위프트 라이브러리에 기본적으로 정의된 연산자를 소개한다.
|연산자|부호|설명|
|---|---|---|
|nil 병합 연산자|A ?? B|A가 nil이 아니면 A를 반환하고, A가 nil이면 B를 반환한다.
|부호변경 연산자|-A|A(수)의 부호를 변경한다.
|옵셔널 강제 추출 연산자|O!|O(옵셔널 개체)의 값을 강제로 추출한다.
|옵셔널 연산자|V?|V(옵셔널 값)를 안전하게 추출하거나, V(데이터 타입)가 옵셔널임을 표현한다.

**NOTE_ nil 병합 연산자**

nil 병합 연산자는 옵셔널을 사용할 때 아주 유용한 연산자이다. 아직 옵셔널에 대해 배우지 않았지만 차후 옵셔널을 배우고 nil 병합 연산자를 다시 확인해보길 바란다. 다음 두 코드는 같은 역할을 하지만, 아래의 nil 병합 연산자를 사용하는 것이 훨씬 안전하고 간단한 방법이다.

```swift
let valueInt: Int = someOptionalInt != nil ? someOptionalInt! : 0
let valueInt: Int = someOptionalInt ?? 0
```
