# 5. 연산자

스위프트의 연산자는 특정한 문자로 표현한 함수라 할 수 있다. 따라서 특정 연산자의 역할을 프로그래머의 의도대로 변경할 수 있다.

연산자에 의해 연산 되는 값의 수에 따라 단항, 이항, 삼항 등으로 구분하기도 하며, 연산자의 위치에 따라 전위, 중위, 후위 등으로 구분하기도 한다.

|분류|설명|예|
|---|---|---|
|단항 연산자|피연산자(연산 대상)가 한개인 연산자|!A
|이항 연산자|피연산자가 두 개인 연산자|A + B
|삼항 연산자|피연산자가 세 개인 연산자|A ? B : C
|전위 연산자|연산자가 피연산자 앞에 위치하는 연산자|!A
|중위 연산자|연산자가 피연산자 사이에 위치하는 연산자|A + B
|후위 연산자|연산자가 피연산자 뒤에 위치하는 연산자|A!

이번 장에서는 간단한 예를 들어 연산자를 설명하려 한다. 좀 더 자세한 활용법은 이후 장에서 나오는 코드에서 직접 볼 수 있다. 스위프트에서 추가된 개념이거나 독특한 특성이 있는 연산자는 좀 더 자세히 설명해두었다.

## 5.1 연산자의 종류
연산자는 종류가 굉장히 많다. 먼저 몇 가지 주요 연산자를 하나씩 설명한다.

### 5.1.1 할당 연산자
값을 할당할 때 사용하는 연산자이다.

|연산자|부호|설명|
|---|---|---|
|할당(대입) 연산자|A = B|A에 B의 값을 할당한다. 서로 다른 데이터 타입이면 오류가 발생한다.|

### 5.1.2 산술 연산자
산술 연산자는 대체로 수학에서 쓰이는 연산자와 같은 역할을 수행한다.
|연산자|부호|설명|
|---|---|---|
|더하기 연산자|A + B|A와 B를 더한 값을 반환한다.
|빼기 연산자|A - B|A에서 B를 뺀 값을 반환한다.
|곱하기 연산자|A * B|A에서 B를 곱한 값을 반환한다.
|나누기 연산자|A / B|A를 B로 나눈 값을 반환한다.
|나머지 연산자|A % B|A를 B로 나눈 나머지를 반환한다.

**NOTE_스위프트의 나머지 연산과 나누기 연산자**

스위프트에서는 부동소수점 타입의 나머지 연산까지 지원한다. 기존의 프로그래밍 언어에서는 나머지 연산자가 정수 타입만 지원하는 경우가 많았는데 스위프트에서는 부동소수점 타입도 나머지 연산을 할 수 있다.

```swift
let number: Double = 5.0
var result: Double = number.truncatingRemainder(dividingBy: 1.5) // 0.5
result = 12.truncatingRemainder(dividingBy: 2.5)                 // 2.0
```

나누기 연산은 기존의 프로그래밍 언어처럼 나머지나 소수점을 제외한 정수만을 결과값으로 반환한다.

```swift
var result: Int = 5 / 3     // 1
result = 10 / 3             // 3
```

또한, 스위프트는 데이터 타입에 굉장히 엄격하므로 서로 다른 자료형끼리의 연산을 엄격히 제한한다. 서로 다른 자료형끼리의 연산을 실행하려면 값을 해당 타입으로 변환한 후 연산해야 한다.

### 5.1.3 비교 연산자
두 값을 비교할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|값이 같다.| A == B|A와 B가 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 크거나 같다.| A >= B|A가 B보다 크거나 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 작거나 같다.| A <= B|A가 B보다 작거나 같은 값인지 비교하여 불리언 값을 반환한다.
|값이 크다.| A > B|A가 B보다 큰 값인지 비교하여 불리언 값을 반환한다.
|값이 작다.| A < B|A가 B보다 작은 값인지 비교하여 불리언 값을 반환한다.
|값이 같지 않다.| A != B |A와 B가 다른 값인지 비교하여 불리언 값을 반환한다.
|참조가 같다|A === B|A와 B가 참조(레퍼런스) 타입일 때 A와 B가 같은 인스턴스를 가리키는 비교하여 불리언 값을 반환한다.
|참조가 같지 않다.|A !== B|A와 B가 참조(레퍼런스) 타입일 때 A와 B가 같지 않은 인스턴스를 가리키는지 비교하여 불리언 값을 반환한다.
|패턴 매치|A ~= B|A와 B의 패턴이 매치되는지 확인하여 불리언 값을 반환한다.

**NOTE_참조 비교 연산자**

스위프트의 유일한 참조타입인 클래스의 인스턴스에서만 참조 비교 연산자를 사용할 수 있다. 스위프트의 기본 데이터 타입은 모두 구조체로 구현되어 있기 때문에 값 타입이다. 그렇기 때문에 값의 비교 연산에는 ==를 사용하고 클래스의 인스턴스인 경우에만 ===를 사용한다. 구조체와 클래스, 값 타입과 참조 타입에 대해서는 값 타입과 참조 타입에서 더 자세히 알아본다.

```swift
let valueA: Int = 3
let valueB: Int = 5
let valueC: Int = 5

let isSameValueAB: Bool = valueA == valueB      // false
let isSameValueBC: Bool = valueB == valueC      // true

let referenceA: SomeClass = SomeClass()
let referenceB: SomeClass = SomeClass()
let referenceC: SomeClass = referenceA

let isSameReferenceAB: Bool = referenceA === referenceB     // false
let isSameReferenceAC: Bool = referenceA === referenceC     // true
```

### 5.1.4 삼항 조건 연산자
피연산자가 세 개인 삼항 조건 연산자이다.
|연산자|부호|설명|
|---|---|---|
|삼항 조건 연산자|Question ? A : B|Question(불리언 값)이 참이면 A, 거짓이면 B를 반환한다.

삼항 조건 연산자를 사용하면 조건식을 간단히 한 줄에 표현할 수 있다.

```swift
var valueA: Int = 3
var valueB: Int = 5
var biggerValue: Int = valueA > valueB ? valueA : valueB    // 5

valueA = 0
valueB = -3
biggerValue = valueA > valueB ? valueA : valueB             // 0

var stringA: String = ""
var stringB: String = "String"
var resultValue: Double = stringA.isEmpty ? 1.0 : 0.0       // 1.0
resultValue = stringB.isEmpty ? 1.0 : 0.0                   // 0.0
```

물론, 조건 안에 또 다른 삼항 연산자를 넣을 수도 있고, 여러번 중첩할 수도 잇지만, 중첩을 너무 많이 사용하면 오히려 코드를 이해하기 어려우므로 적절히 사용할 줄 아는 지혜가 필요하다.

### 5.1.5 범위 연산자
값(수)의 범위를 나타내고자 할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|폐쇄 범위 연산자|A...B|A부터 B까지의 수를 묶어 범위를 표현한다. A와 B를 포함한다.
|반폐쇄 범위 연산자|A..<B|A부터 B미만까지의 수를 묶어 범위를 표현한다. A를 포함하고, B를 포함하지 않는다.
|단방향 범위 연산자|A.. |A 이상의 수를 묶어 범위를 표현한다. A를 포함한다.
||...A|A 이하의 수를 묶어 범위를 표현한다. A를 포함한다.
||..<A|A 미만의 수를 묶어 범위를 표현한다. A를 포함하지 않는다.

### 5.1.6 부울 연산자
불리언 값의 논리 연산을 할 때 사용한다.
|연산자|부호|설명|
|---|---|---|
|NOT(부정) 부울 연산자|!B|B(불리언 값)의 참, 거짓을 반전한다.
|AND 부울 연산자| A && B | A와 B의 불리언 AND 논리 연산을 실행한다.
|OR 부울 연산자| A \|\| B |A와 B의 불리언 OR 논리연산을 실행한다.

### 5.1.7 비트 연산자
값의 비트 논리 연산을 위한 연산자이다.

|연산자|부호|설명|
|---|---|---|
|NOT(부정) 비트 연산자|~A|A의 비트를 반전한 결과를 반환한다.
|AND 비트 연산자|A & B|A와 B의 비트 AND 논리 연산을 실행한다.
|OR 비트 연산자| A \| B|A와 B의 OR 논리 연산을 실행한다.
|XOR 비트 연산자| A^B |A와 B의 비트 XOR 논리 연산을 실행한다.
|비트 이동 연산자(시프트연산자)|A >> B, A << B|A의 비트를 B만큼 비트를 시프트(이동)한다.

시프트 연산자는 지정하는 수만큼 피연산자를 왼쪽(<<) 또는 오른쪽(>>)으로 이동한다. 예를 들어 정수 4(0100)을 왼쪽으로 1 시프트 연산할때 4 << 1 로 표현해줄 수 있다. 왼쪽으로 비트를 이동했기 때문에 결과는 8(1000)이 된다. 반대로 오른쪽 1 시프트 연산을 하면 4 >> 1 로 표현할 수 있고 결과는 2(0010)가 된다.

위의 왼쪽 비트 연산의 결과처럼 시프트 한 후 빈 자리는 0으로 채워진다. 반대로 시프트 연산을 하면서 비트 범위를 벗어난 비트는 버려진다. 만약 7(0111)을 오른쪽 2 시프트 연산을 하면, 결과는 1(0001)이 된다.

### 5.1.8 복합 할당 연산자
할당 연산자와 다른 연산자가 하는 일을 한 번에 할 수 있도록 연산자를 결합할 수 있다. 이를 복합 할당 연산자라고 한다.
|표현|설명|같은 표현|
|---|---|---|
|A += B|A와 B의 합을 A에 할당한다.|A = A + B
|A -= B|A와 B의 차를 A에 할당한다.|A = A - B
|A *= B|A와 B의 곱을 A에 할당한다.|A = A * B
|A /= B|A를 B로 나눈 값을 A에 할당한다.|A = A / B
|A %= B|A를 B로 나눈 나머지를 A에 할당한다.|A = A % B
|A <<= N|A를 N만큼 왼쪽 비트 시프트 한 값을 A에 할당한다.|A = A << N
|A >>= N|A를 N만큼 오른쪽 비트 시프트 한 값을 A에 할당한다.|A = A >> N
|A &= B|A와 B의 비트 AND 연산 결과를 A에 할당한다.|A = A & B
|A \|= B|A와 B의 비트 OR 연산 결과를 A에 할당한다.|A = A \| B
|A ^= B|A와 B의 비트 XOR 연산 결과를 A에 할당한다.|A = A ^ B

### 5.1.9 오버플로 연산자
기존 프로그래밍 언어에서는 오버플로(또는 언더플로) 가능성이 있는 연산에 대해서는 따로 오버플로에 대한 추가 알고리즘 및 로직 등을 설계하는 것이 일반적이었다. 스위프트는 기본 연산자를 통해 오버플로에 대비할 수 있도록 준비해두었다. 오버플로 연산자를 사용하면 오버플로를 자동으로 처리한다.

|연산자|부호|설명|
|---|---|---|
|오버플로 더하기 연산|&+|오버플로에 대비한 덧셈 연산을 한다.
|오버플로 뺴기 연산|&-|오버플로에 대비한 뺄셈 연산을 한다.
|오버플로 곱하기 연산|&*|오버플로에 대비한 곱셈 연산을 한다.

예를 들어 UInt8 타입은 8비트 정수 타입으로 부호가 없는 양의 정수만을 표현하기 때문에 0 아래로 내려가는 계산을 하면 런타임 오류가 발생한다. 그렇지만 오버플로 빼기 연산을 사용하면 오류 없이 오버플로 처리를 해준다. 그렇지만 오버플로에 대한 이해 없이 사용한다면 엉뚱한 값을 구할 수도 있다. 따라서 오버플로에 대해 먼저 이해하고 사용해야 한다.

```swift
var unsignedInterger: UInt8 = 0
let errorUnderflowResult: UInt8 = unsignedInterger - 1      // 런타임 오류
let underflowedValue: UInt8 = unsignedInterger &- 1         // 255

unsignedInterger = UInt8.max
let errorOverflowResult: UInt8 = unsignedInterger + 1       // 런타임 오류
let overflowedValue: UInt8 = unsignedInterger + 1           // 0
```

### 5.1.10 기타 연산자
앞서 소개한 연산자 외에 스위프트 라이브러리에 기본적으로 정의된 연산자를 소개한다.
|연산자|부호|설명|
|---|---|---|
|nil 병합 연산자|A ?? B|A가 nil이 아니면 A를 반환하고, A가 nil이면 B를 반환한다.
|부호변경 연산자|-A|A(수)의 부호를 변경한다.
|옵셔널 강제 추출 연산자|O!|O(옵셔널 개체)의 값을 강제로 추출한다.
|옵셔널 연산자|V?|V(옵셔널 값)를 안전하게 추출하거나, V(데이터 타입)가 옵셔널임을 표현한다.

**NOTE_ nil 병합 연산자**

nil 병합 연산자는 옵셔널을 사용할 때 아주 유용한 연산자이다. 아직 옵셔널에 대해 배우지 않았지만 차후 옵셔널을 배우고 nil 병합 연산자를 다시 확인해보길 바란다. 다음 두 코드는 같은 역할을 하지만, 아래의 nil 병합 연산자를 사용하는 것이 훨씬 안전하고 간단한 방법이다.

```swift
let valueInt: Int = someOptionalInt != nil ? someOptionalInt! : 0

// 위 코드와 같은 결과를 볼 수 있지만 훨씬 안전하게 옵셔널을 다룰 수 있다.
let valueInt: Int = someOptionalInt ?? 0

// 참고로 옵셔널 강제 추출 연산자 사용은 지양하는 편이 좋다.
```

## 5.2 연산자 우선순위와 결합방향
C 언어 등 기존 언어에서 연산자는 연산자 우선순위를 쉽게 알기 어려웠다. 그러나 스위프트에서는 연산자 **우선순위** 를 지정해 놓았기 때문에 코딩하다가 헷갈리는 경우 확인하면 된다. 우선순위가 높은 연산자는 자신에 비해서 우선순위가 낮은 연산자보다 먼저 실행된다. 프로그래머가 임의로 정의하는 사용자 정의 연산자 또한 이 규칙에 따라 실행 순서가 결정된다.

또 연산자가 연산하는 **결합방향**도 지정되어있다. 결합방향은 같은 우선순위에 있는 연산자끼리 나열되었을 때 어느 방향부터 그룹지을 것인지 나타낸다. 예를 들어 1 + 2 + 3 + 4라는 수식이 있다면, 연산자 +는 모두 같은 우선도를 가지며 +의 결합방향은 왼쪽이기 때문에 (((1 + 2) + 3) + 4) 처럼 왼쪽부터 그룹이 묶이는 것이다. 그래서 1 + 2가 가장 먼저 연산이 되고 연산된 결과가 다시 3과 연산이 되고 그 결과가 다시 4와 연산이 되는 것이다.

기본 연산자들의 우선도와 결합방향을 알아보려면 스위프트 표준 라이브러리의 연산자 정의를 참고하면 된다.

## 5.3 사용자 정의 연산자
스위프트에서는 사용자(프로그래머)의 입맛에 맞게 연산자 역할을 부여할 수 있다. 또, 기존에 존재하지 않던 연산자 기호를 만들어 추가할 수 있다. **이번 사용자 정의 연산자 파트는 함수, 클래스, 메서드 등의 선수개념이 필요하다.** 읽어보고 어렵다면 해당 내용을 먼저 익힌 후 돌아와서 다시 보길 추천한다.

**NOTE_ = 과 ?:**

할당 연산자(=)와 삼항 연산자(?:)는 사용자 정의 역할을 부여할 수 없다.

우선 기존 연산자의 역할을 변경하거나 새로운 역할을 추가하기 위해서는 기존의 연산자가 전위 연산자인지, 중위 연산자인지, 후위 연산자인지 알아야 한다.

전위 연산자는 연산자가 피연산자 앞에 위치하는 연산자를 뜻한다. 대표적인 예로 부울 부정 논리연산(NOT) 연산자(!)가 있다.

중위 연산자는 피연산자 사이에 위치하는 연산자를 뜻한다. 많은 수의 연산자가 여기 속한다.

후위 연산자는 피연산자 뒤에 있는 연산자를 뜻한다. 대표적인 예로 옵셔널 강제 추출 연선자 등이 있다.

infix라는 키워드는 중위 연산자를 뜻하고, prefix는 전위, postfix는 후위 연산자를 뜻한다.

operator라는 키워드는 연산자임을 뜻하고, associativity는 연산자 결합방향을 뜻한다. precedence라는 키워드는 우선순위를 뜻한다.

사용자 정의 연산자는 아스키문자 /,=,-.+,!,*,%,<,>,&,|,^,?,~ 를 결합해서 사용한다.

또 마침표(.)를 사용자 정의 연산자에 사용할 수 있다. 다만 마침표를 사용자 정의 연산자에 사용할 때 주의할 점이 있다. 연산자를 표현하는 문자 중 맨 처음의 문자가 마침표일 때만 연산자에 포함된 마침표가 연산자로 인식한다. 예를들어 .+. 처럼 사용할 수 있다. 만약 마침표로 시작되지 않는 연산자에 마침표가 들어가게 되면 이를 인식할 수 없다. 예를 들어 +.+의 경우에는 + 연산자와 .+ 연산자를 사용한 것으로 인식된다.

물음표(?)도 사용자 정의 연산자에 포함시킬 수 있지만 물음표 자체만으로는 사용자 정의 연산자를 정의할 수 없다. 더불어 사용자 정의 연산자에 느낌표(!)도 같은 조건으로 포함시킬 수 있다. 단, 전위 연산자는 물음표나 느낌표로 시작하는 사용자 정의 연산자를 정의할 수 없다.

토큰으로 사용되는 =, ->, //, /*, */, . 과 전위 연산자 <, &, ?, 중위 연산자?, 후위 연산자 >, !, ? 등은 이미 스위프트에서 예약한 상태이기 때문에 재정의할 수 없으며 사용자 정의 연산자로 사용될 수도 없다.

### 5.3.1 전위 연산자 정의와 구현
Int 타입의 제곱을 구하는 연산자로 **을 전위 연산자로 사용하려고 한다. 기존에 없던 전위 연산자를 만들고 싶다면 연산자 정의를 먼저 해주어야 한다. 정의하는 뜻은 '이제 이 연산자를 사용하겠다' 라고 알리는 것을 뜻한다. 정의된 연산자는 모듈 전역에서 사용된다.

```swift
prefix operator **
```

연산자의 정의를 마치면, 어떤 데이터 타입에 이 연산자가 동작할 것인지 함수를 구현한다. 전위 연산자 함수를 구현할 때는 함수 func 키워드 앞에 prefix 키워드를 추가해준다. func나 return 같이 아직 설명하지 않은 표현들도 있지만 무엇을 의미할지 한번 유추해보자.

```swift
prefix operator **

prefix func ** (value: Int) -> Int {
    return value * value
}

let minusFive: Int = -5
let sqrtMinusFive: Int = **minusFive

print(sqrtMinusFive)    // 25
```

스위프트 표준 라이브러리에 존재하는 전위 연산자에 기능을 추가할 때는 따로 연산자를 정의하지 않고 함수만 중복 정의하면 된다. 첫번째로 생각해볼 예제에서는 기존에 존재하는 전위 연산자 중 정수에 사용되는 느낌표(!)를 문자열에도 사용하고자 한다. 문자열 앞에 사용하면 문자열이 비어있는지 확인하는 연산자로 사용하기 위해 함수를 중복 정의해준다.

```swift
prefix func ! (value: String) -> Bool {
    return value.isEmpty
}

var stringValue: String = "minseok"
var isEmptyString: Bool = !stringValue

print(isEmptyString)        // false

stringValue = ""
isEmptyString = !stringValue
print(isEmptyString)        // true
```

또 앞서 만들었던 ** 연산자를 String 타입에서도 동작할 수 있도록 중복 정의해줄 수 있다.

```swift
prefix operator **

prefix func ** (value: String) -> String {
    return value + " " + value
}

let resultString: String = **"minseok"

print(resultString)     // minseok minseok
```

### 5.3.2 후위 연산자 정의와 구현
이번에는 후위 연산자를 사용자 정의하는 방법을 알아보자. 사용자 정의 전위 연산자를 구현 한 것과 크게 다르지 않다. 다음 코드에서는 정수 타입의 값 뒤에 \*\*를 붙이면 10을 더해주는 연산을 구현해보겠다. 후위 연산자의 함수 구현 앞에는 **postfix** 라는 키워드를 붙여준다.

```swift
postfix operator **

postfix func ** (value: Int) -> Int {
    return value + 10
}

let five: Int = 5
let fivePlusTen: Int = five**

print(fivePlusTen)      // 15
```

**하나의 피 연산자에 전위 연산과 후위 연산을 한 줄에 사용하게 되면 후위 연산을 먼저 수행한다.**

```swift
prefix operator **
postfix operator **

prefix func ** (value: Int) -> Int {
    return value * value
}
postfix func ** (value: Int) -> Int {
    return value + 10
}

let five: Int = 5
let fivePlusTen: Int = **five**

print(fivePlusTen)      // (10 + 5) * (10 + 5) == 225
```

### 5.3.3 중위 연산자 정의와 구현
중위 연산자 정의도 전위 연산자나 후위 연산자 정의와 크게 다르지 않다. 다만 중위 연산자는 우선순위 그룹을 명시해줄 수 있다.

우선 연산자 우선순위 그룹을 정의하는 방법에 대해 알아보자. 연산자 우선순위 그룹은 precedencegroup 뒤에 그룹 이름을 써주어 정의할 수 있따.

```swift
precedencegroup 우선 순위 그룹 이름 {
    higherThan: 더 낮은 우선순위 그룹 이름
    lowerThan: 더 높은 우선순위 그룹 이름
    associativity: 결합방향 (left / right / none)
    assignment: 할당방향 사용 (true / false)
}
```

연산자 우선순위 그룹은 중위 연산자에서만 사용된다. 전위 연산자 및 후위 연산자는 결합방향 및 우선순위를 지정하지 않는다. 대신, 앞서 설명했듯 하나의 피연산자에 전위 연산과 후위 연산을 한 줄에 사용하게 되면 후위 연산을 먼저 수행한다.

더 낮은 우선순위 그룹 이름을 넣을 수 있는 higherThan과 더 높은 우선순위 그룹 이름을 넣을 수 있는 lowerThan에 들어갈 수 있는 그룹 이름을 통해 기존의 우선순위 그룹과 새로 만들어줄 우선순위 그룹과의 상하관계를 설정해 줄 수 있다. lowerThan 속성에는 현재 모듈밖에 정의된 우선순위 그룹만 명시할 수 있다.

결합방향을 명시해줄 수 있는 associativity에는 left, right, none을 지정해 줄 수 있다. 만약 associativity를 빼놓고 연산자 우선순위 그룹을 정의하면 기본적으로 none이 설정된다. 결합방향이 없는 연산자는 여러 번 연달아 사용할 수 없다. 결합방향이 있는 더하기(+) 또는 빼기(-) 등의 연산자는 1 + 2 + 3과 같이 연산해줄 수 있고, 3 - 2 - 1과 같이 연산해줄 수 있다. 결합방향이 있는 연산자는 섞어서 1 + 2 - 3처럼도 사용할 수 있다. 그렇지만 결합방향이 없는 부등호 연산자(>)의 경우네는 연달아 사용해줄 수 없다. 1 < 2 < 3과 같은 모양으로 사용할 수 없다는 뜻이다.

연산자 우선순위 그룹의 assignment는 옵셔널 체이닝과 관련된 사항이다. 연산자가 옵셔널 체이닝을 포함한 연산에 포함되어 있을 경우 연산자의 우선순위를 지정한다. true로 설정해주면 해당 우선순위 그룹에 해당하는 연산자 옵셔널 체이닝을 할 때 표준 라이브러리의 할당 연산자와 동일한 결합방향 규칙을 사용한다. 즉, 스위프트의 할당 연산자는 오른쪽 결합을 사용하므로 assignment를 true로 설정하면 연산자를 사용하여 옵셔널 체이닝을 할 때 오른쪽부터 체이닝이 시작된다는 뜻이다. 그렇지 않고 false를 설정하거나 assignment를 따로 명시해주지 않으면 해당 우선순위 그룹에 해당하는 연산자는 할당을 하지 않는 연산자와 같은 옵셔널 체이닝 규칙을 따른다. 즉, 연산자에 옵셔널 체이닝 기능이 포함되어 있다면 왼쪽부터 옵셔널 체이닝을 하게 된다.

**만약, 중위 연산자를 정의할 때 우선순위 그룹을 명시해주지 않는다면 우선순위가 가장 높은 DefalutRecedence 그룹을 우선순위 그룹으로 갖게된다.**

연산자 우선순위 그룹을 정의하는 방법을 알아보았으니 본격적으로 중위 연산자를 정의하는 방법에 대해 알아보자. 중위 연산자의 정의에는 infix라는 키워드를 사용한다.

다음 코드에서 \*\*를 중위 연산자로 사용하기 위해 정의해보자. 연산자의 이름은 \*\*이고, MultiplicationPrecedence 연산자 우선순위 그룹에 속하게 된다.

**만약 MultiplicationPrecedence 라고 명시해주지 않는다면 DefaultPrecedence 그룹으로 자동 지정된다.

```swift
infix operator ** : MultiplicationPrecedence
```

연산자 정의를 했으니 이제 구현할 차례다. 문자열과 문자열 사이에 ** 연산자를 사용하면 뒤에 오는 문자열이 앞의 문자열 안에 속해 있는지 확인하는 연산을 실행하도록 구현하겠다. 중위 연산자 구현 함수에는 따로 키워드를 추가하지 않는다.
```swift
// String 타입의 contains(_ :) 메서드를 사용하기 위해 Foundation 프레임워크를 임포트한다.
import Foundation

infix operator ** : MultiplicationPrecedence

func ** (lhs: String, rhs: String) -> Bool {
    return lhs.contains(rhs)
}

let helloMinseok: String = "Hello minseok"
let minseok: String = "minseok"
let isContainsMinseok: Bool = helloMinseok ** minseok       // true
```

코드를 살펴보면 우리가 정의한 데이터 타입(클래스, 구조체 등)에서 유용하게 사용할 수 있는 연산자도 새로 정의하거나 중복 정의할 수 있음을 알 수 있다.

```swift
class Car {
    var modelYear: Int?     // 연식
    var modalName: String?  // 모델 이름
}

struct SmartPhone {
    var company: String?
    var model: String?
}

// Car 클래스의 인스턴스끼리 == 연산했을 때 modelName이 같다면 true를 반환
func == (lhs: Car, rhs: Car) -> Bool {
    return lhs.modalName == rhs.modalName
}

// SmartPhone 구조체의 인스턴스끼리 == 연산했을 때 model이 같다면 true를 반환
func == (lhs: SmartPhone, rhs: SmartPhone) -> Bool {
    return lhs.model == rhs.model
}

let myCar = Car()
myCar.modalName = "S"

let yourCar = Car()
yourCar.modalName = "S"

var myPhone = SmartPhone()
myPhone.model = "SE"

var yourPhone = SmartPhone()
yourPhone.model = "6"

print(myCar == yourCar)         // true
print(myPhone == yourPhone)     // false
```

위의 코드의 사용자 정의 연산자는 마찬가지로 전역함수로 구현했다. 그러나 특 타입에 국한된 연산자 함수라면 그 타입 내부에 구현되는 것이 읽고 이해하기에 더욱 쉬울 것이다. 그래서 타입 내부에 타입 메서드로 구현할 수도 있다. 다음 코드에서 타입 메서드로 구현된 사용자 정의 연산자 함수를 확인해볼 수 있다.

```swift
class Car {
    var modelYear: Int?     // 연식
    var modalName: String?  // 모델 이름

    // Car 클래스의 인스턴스끼리 == 연산했을 때 modelName이 같다면 true를 반환
    static func == (lhs: Car, rhs: Car) -> Bool {
        return lhs.modalName == rhs.modalName
    }
}

struct SmartPhone {
    var company: String?
    var model: String?

    // SmartPhone 구조체의 인스턴스끼리 == 연산했을 때 model이 같다면 true를 반환
    static func == (lhs: SmartPhone, rhs: SmartPhone) -> Bool {
        return lhs.model == rhs.model
    }
}
```

위의 코드에서 타입 메서드로 구현한 사용자 정의 연산자는 각 타입의 익스텐션으로 구현해도 된다. 익스텐션을 통해 타입 메서드로 구현한 사용자 정의 메서드는 익스텐션으로 추가할 수 있는 기능에서 확인해볼 수 있다.

지금까지 간단한 예를 들어 설명했지만, 실제로 스위프트로 프로그램을 만들면서 활용하게 될 사용자 정의 연산자는 굉장히 강력한 무기가 될 수 있다. 복잡한 연산을 하나의 특수문자로 구현한다면 일반 함수만으로 기능을 실행하는 것보다 훨씬 강력할 것 이다.
