# 4. 데이터 타입 고급

## 4.1 데이터 타입 안심
애플이 처음 스위프트를 발표할 때 강조했던 스위프트의 특징 중 **안정성**이 가장 뚜렷하게 나타나는 부분이다. 스위프트는 타입에 굉장히 민감하고 엄격하다. 서로 다른 타입끼리의 데이터 교환은 꼭 타입캐스팅을 거쳐야 한다. 스위프트에서 값 타임의 데이터 교환은 엄밀히 말하면 타입캐스팅이 아닌 새로운 인스턴스를 생성하여 할당하는 것이다.

### 4.1.1 데이터 타입 안심이란
스위프트는 데이터 타입을 안심하고 사용할 수 있는 언어이다. 타입을 안심하고 사용할 수 있다는 말은 그만큼 실수를 줄일 수 있다는 의미이다. 예를 들어 Int 타입 변수에 할당하려는 값이 Character 타입이라면 컴파일 오류가 발생한다. 이런 오류는 프로그래밍 도중에 눈치채기 어려워 컴파일러가 알려주지 않으면 나중에 오류를 찾아내기도 쉽지 않다. 그렇지만 스위프트는 컴파일 오류로 알려주므로 서로 다른 타입의 값을 할당하는 실수를 줄일 수 있다. 이렇게 스위프트가 컴파일시 타입을 확인하는 것을 **타입 확인**이라고 한다. 타입 확인을 통해 여러 타입을 섞어 사용할 때 발생할 수 있는 런타임 오류를 피할 수 있다.

### 4.1.2 타입 추론
스위프트에서는 변수나 상수를 선언할 때 특정 타입을 명시하지 않아도 컴파일러가 할당된 값을 기준으로 변수나 상수의 타입을 결정한다. 예를 들어 let name = "minseok"라는 코드를 작성하면, 컴파일러가 컴파일하면서 name의 타입을 String으로 결정한다.

## 4.2 타입 별칭
스위프트에서 기본으로 제공하는 데이터 타입이든, 사용자가 임의로 만든 데이터 타입이든 이미 존재하는 데이터 타입에 임의로 다른 이름(별칭)을 부여할 수 있다. 그런 다음 기본 타입 이름과 이후에 추가한 별칭을 모두 사용할 수 있다.

```swift
typealias  MyInt = Int
typealias  YourInt = Int
typealias MyDouble = Double

let age: MyInt = 100        // MyInt는 Int의 또 다른 이름이다.
var year: YourInt = 2080    // YourInt도 Int의 또 다른 이름이다.

// MyInt도, YourInt도 Int이기 때문에 같은 타입으로 취급한다.
year = age

let month: Int = 7          // 물론 기존의 Int도 사용 가능하다.
let percentage: MyDouble = 99.9 // Int외에 다른 자료형도 모두 별칭 사용이  가능하다.
```

## 4.3 튜플
**튜플**은 타입의 이름이 따로 지정되어 있지 않은, 프로그래머 마음대로 만드는 타입이다. **'지정된 데이터의 묶음'** 이라고 표현할 수 있다.

스위프트의 튜플은 파이썬의 튜플과 유사하다. 튜플은 타입 이름이 따로 없으므로 일정 타입의 나열만으로 튜플 타입을 생성해줄 수 있다. 튜플에 포함될 데이터의 개수는 자유롭게 정할 수 있다. 하나가 될 수도, 두 개가 될 수도, 열 개가 될 수도 있다.

```swift
// String, Int, Double 타입을 갖는 튜플
var person: (String, Int, Double) = ("minseok", 100, 173.5)

// 인덱스를 통해서 값을 빼 올 수 있다.
print("이름: \(person.0), 나이: \(person.1), 신장: \(person.2)")

person.1 = 99 // 인덱스를 통해 값을 할당할 수 있다.
person.2 = 178.5

print("이름: \(person.0), 나이: \(person.1), 신장: \(person.2)")
```

위의 코드에서는 튜플의 각 요소를 이름 대신 숫자로 표현하기 때문에 간편해 보일 수 있지만, 차후에 다른 프로그래머가 코드를 볼 때 각 요소가 어떤 의미가 있는지 유추하기가 어렵다. 이름 없이 인덱스로 각 요소의 데이터가 무엇을 나타내는지 쉽게 파악하기 어렵기 때문이다. 그래서 튜플의 요소마다 이름을 붙여줄 수 있다.

```swift
// String, Int, Double 타입을 갖는 튜플
var person: (name: String, age: Int, height: Double) = ("minseok", 100, 173.5)

// 요소 이름을 통해서 값을 빼 올 수 있다.
print("이름: \(person.name), 나이: \(person.age), 신장: \(person.height)")

person.1 = 99 // 인덱스를 통해 값을 할당할 수 있다.
person.height = 178.5 // 요소 이름을 통해서도 값을 할당할 수 있다.

// 기존처럼 인덱스를 이용하여 값을 빼 올 수도 있다.
print("이름: \(person.0), 나이: \(person.1), 신장: \(person.2)")
```

또, 튜플에는 타입 이름에 해당하는 키워드가 따로 ㅇ벗다보니 사용에 불편함을 겪기도 한다. 매번 같은 모양의 튜플을 사용하고 싶은데 선언해줄 때마다 긴 튜플 타입을 모두 써줘야 하는 불편함이 생길 수 있기 때문이다. 이럴 때는 타입 별칭을 사용하여 조금 더 깔끔하고 안전하게 코드를 작성할 수 있다.

```swift
typealias PersonTuple = (name: String, age: Int, height: Double)

let minseok: PersonTuple = ("minseok", 100, 178.5)
let mandos: PersonTuple = ("mandos", 150, 185.2)

print("이름: \(minseok.name), 나이: \(minseok.age), 신장: \(minseok.height)")
print("이름: \(mandos.name), 나이: \(mandos.age), 신장: \(mandos.height)")
```

## 4.4 컬렉션형
스위프트는 튜플 외에도 많은 수의 데이터를 묶어서 저장하고 관리할 수 있는 컬렉션 타입을 제공한다. 컬렉션 타입에는 배열, 딕셔너리, 세트 등이 있다.

### 4.4.1 배열
배열은 같은 타입의 데이터를 일렬로 나열한 후 순서대로 저장하는 형태의 컬렉션 타입이다. 각기 다른 위치에 같은 값이 들어갈 수도 있다.

배열 타입을 선언해줄 방법은 다양하다. let 키워드를 사용해 상수로 선언하면 변경할 수 없는 배열이 되고, var 키워드를 사용해 변수로 선언해주면 변경 가능한 배열이 된다. 실제로 배열을 사용할 때는 Array라는 키워드와 타입 이름의 조합으로 사용한다. 또, 대괄호로 값을 묶어 Array 타입임을 표현할 수도 있다. 빈 배열은 이니셜라이저 또는 리터럴 문법을 통해 생성해줄 수 있는데 isEmpty 프로퍼티로 비어있는 배열인지 확인해볼 수 있다. 그리고 배열에 몇 개의 요소가 존재하는지 알고 싶으면 count 프로퍼티를 확인하면 된다.

**NOTE_스위프트의 Array**

스위프트의 Array는 C 언어의 배열처럼 버퍼이다. 단, C언어 처럼 한 번 선언하면 크기가 고정되던 버퍼가 아니라, 필요에 따라 자동으로 버퍼의 크기를 조절해주므로 요소의 삽입 및 삭제가 자유롭다. 스위프트는 이럴 리스트 타입을 Array, 즉 배열이라고 표현한다.

```swift
// 대괄호를 사용하여 배열임을 표현한다.
var names: Array<String> = ["minseok", "chulsoo", "mandos", "minseok"]

// 위 선언과 정확히 동일한 표현이다. [String]은 Array<String>의 축약 표현이다.
// var names: [String] = ["minseok", "chulsoo", "mandos", "minseok"]

var emptyArray: [Any] = [Any]() // Any 데이터를 요소로 갖는 빈 배열을 생성한다.
// var emptyArray: [Any] = Array<Any>() // 위 선언과 정확히 동일한 표현이다.

// 배열의 타입을 정확히 명시해줬다면 []만으로도 빈 배열을 생성할 수 있다.
// var emptyArray: [Any] = []
print(emptyArray.isEmpty) // true
print(names.count) // 4
```
배열은 각 요소에 인덱스를 통해 접근할 수 있다. 인덱스는 0부터 시작한다. 잘못된 인덱스로 접근하려고 하면 익셉션 오류가 발생한다. 또, 맨 처음과 맨 마지막 요소는 first와 last 프로퍼티를 통해 가져올 수 있다. index(of:) 메서드를 사용하면 해당 요소의 인덱스를 알아낼 수 있다. 만약 중복된 요소가 있다면 제일 먼저 발견된 요소의 인덱스를 반환한다. 맨 뒤에 요소를 추가하고 싶다면 append() 메서드를 사용한다.

중간에 요소를 삽입하고 싶다면 insert(\_:at:) 메서드를 사용하면 된다. 요소를 삭제하고 싶다면 remove() 메서드를 사용하게 되는데, 메서드를 사용하면 해당 요소가 삭제된 후 반환된다.

```swift
var names: Array<String> = ["minseok", "chulsoo", "mandos", "minseok"]
var emptyArray: [Any] = [Any]()

print(names[2])         // mandos
names[2] = "jenny"
print(names[2])         // jenny
// print(names[4])      // 인덱스의 범위를 벗어났기 때문에 오류 발생
// names[4] = "elsa"    // 인덱스의 범위를 벗어났기 때문에 오류 발생

names.append("elsa")    // 마지막에 elsa가 추가된다.
names.append(contentsOf: ["john", "max"])       // 맨 마지막에 john과 max가 추가된다.
names.insert("happy", at: 2)                    // 인덱스 2에 삽입된다

// 인덱스 5의 위치에 jinhee와minsoo 가 삽입된다.
names.insert(contentsOf: ["jinhee", "minsoo"], at: 5)

print(names) // ["minseok", "chulsoo", "happy", "jenny", "minseok", "jinhee", "minsoo", "elsa", "john", "max"]
print(names[4])                                 // minseok
print(names.firstIndex(of: "minseok")!)         // 0
print(names.firstIndex(of: "crystal"))          // nil
print(names.first)                              // minseok
print(names.last)                               // max

let firstItem: String = names.removeFirst()
let lastItem: String = names.removeLast()
let indexZeroItem: String = names.remove(at: 0)

print(firstItem)                                // minseok
print(lastItem)                                 // max
print(indexZeroItem)                            // chulsoo
print(names[1 ... 3])                           // ["jenny", "minseok", "jinhee"]
```
