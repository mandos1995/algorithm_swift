# 더 알아두면 좋은 알고리즘
## 소수의 판별
소수란 2보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수이다.

간혹 코딩 테스트에서는 어떠한 자연수가 소수인지 아닌지 판별해야 하는 경우가 생긴다. 혹은 1부터 N까지의 모든 소수를 출력해야 하는 문제 등이 출제될 수 있다. 그렇다면 가장 먼저 어떠한 수 X가 주어졌을 때 해당 수가 소수인지 아닌지 판별하는 방법에 대해서 살펴보자. 가장 간단한 방법은 **X를 2부터 X - 1까지의 모든 수로 나누어보는 것** 이다. 만약 2부터 X - 1까지의 모든 자연수로 나누었을 때 나누어떨어지는 수가 하나라도 존재하면 X는 소수가 아니다.

##### 소수 판별 함수.swift
```swift
// 소수 판별 함수
func is_prime_number(x: Int) -> Bool{
    // 2부터 (x - 1)까지의 모든 수를 확인하며
    for i in 2..<x{
        // x가 해당 수로 나누어떨어진다면
        if x % i == 0{
            return false // 소수가 아님
        }
    }
    return true // 소수
}
print(is_prime_number(x: 4)) // false
print(is_prime_number(x: 7)) // true
```

이 코드의 실행 결과는 차례대로 false, true 인 것을 확인할 수 있다.

시간 복잡도를 계산해보면 이 알고리즘의 시간 복잡도는 *O(X)* 이다. 예를 들어 1,000,000이라는 수가 소수인지 확인해야 할 때는 1,000,000을 2부터 999,999까지의 모든 수에 대하여 하나씩 나누어야 한다. 따라서 이와 같은 알고리즘을 작성하면 **몹시 비효율적**이다.

우리는 이 알고리즘을 개선해서 하나의 수가 소수인지 판별하는 알고리즘은 *O(X)* 보다 더 빠르게 동작하도록 작성할 수 있다. 자연수가 약수가 가지는 특징을 파악하고 있다면 그 원리를 쉽게 이해 할 수 있다. 예를 들어 16이라는 수의 약수는 다음과 같다.

* 1, 2, 4, 8, 16

이때 모든 약수에 대하여, 가운데 약수를 기준으로 하여 대칭적으로 2개씩 앞뒤로 묶어서 곱하면 16을 만들 수 있다.

결과적으로 다음 5개의 등식이 성립하는 것을 확인할 수 있다.

* 1 X 16 = 16
* 2 X 8 = 16
* 4 X 4 = 16
* 8 X 2 = 16
* 16 X 1 = 16

여기에서 알 수 있는 점은 가운데 약수를 기준으로 해서 각 등식이 **대칭적인 형태**를 보인다는 것이다.

예를들어 2 X 8 = 16은 8 X 2 = 16 과 대칭이다. 그렇기 때문에 우리는 특정한 자연수 X가 소수인지 확인하기 위하여 바로 **가운데 약수까지만 '나누어 떨어지는지' 확인**하면 된다. 위의 예시에서는 4까지만 확인하면 된다. 즉 2, 3, 4,를 확인하여 나누어떨어지는지 확인한다. 다시 말해 **제곱근까지만 (가운데 약수까지만) 확인**하면 된다는 점을 기억하자.
##### 개선된 소수 판별 함수.swift
```swift
import Foundation

// 소수 판별 함수
func is_prime_number(x: Int) -> Bool {
    // 2부터 x의 제곱근까지의 모든 수를 확인하며
    for i in 2..<Int(sqrt(Double(x)) + 1) {
        // x가 해당 수로 나누어 떨어진다면
        if x % i == 0{
            return false
        }
    }
    return true
}

print(is_prime_number(x: 4)) // false
print(is_prime_number(x: 7)) // true
```

개선된 소수 판별 알고리즘의 시간 복잡도는 제곱근까지만 확인하면 되기 때문에 시간 복잡도가 *O(X^1/2)* 인 것을 알 수 있다.

제곱근까지만 확인해도 된다는 점에서 시간 복잡도를 매우 많이 개선 할 수 있다. 예를 들어 소수인지 아닌지 판별해야 되는 수가 1,000,000일 때는 반복문 상에서 2부터 1,000까지만 확인하면 되는 것 이다.

이렇게 우리는 하나의 수가 주어졌을 때, 그 수가 소수인지 아닌지 판별하는 알고리즘을 알아보았다. 하지만 하나의 수에 대해서 소수인지 아닌지 판별해야 하는 경우가 아니라, 수의 범위가 주어졌을 때, 그 전체 수의 범위 안에서 존재하는 모든 소수를 찾아야 하는 경우에는 어떻게 해야 할까?

예를 들어 1부터 1,000,000까지의 모든 소수를 출력해야 하는 문제를 만났을 때, 위의 알고리즘을 이용해서 모든 수를 하나씩 검사하는 것으로는 느릴 수 있다.

## 에라토스테네스의 체
에라토스테네스의 체 알고리즘은 **여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘**이다. 에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾으 때 사용할 수 있다.

1. 2부터 N까지의 모든 자연수를 나열한다.
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다.)
4. 더 이상 반복할 수 없을 때 까지 2번과 3번의 과정을 반복한다.

예를 들어 N = 26일때를 확인해보자.

##### step 0
초기 단계에서는 2부터 26 까지의 모든 자연수를 나열한다. [2...26]
##### step 1
남은 수 중에서 아직 처리하지 않은 가장 작은 수를 찾은 다음, 그 수를 제외한 배수를 제거한다. 따라서 2를 제외한 2의 배수는 모두 제외한다. [2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]
##### step 2
남은 수 중에서 아직 처리하지 않은 가장 작은 수를 찾은 다음, 그 수를 제외한 배수를 제거한다. 따라서 3를 제외한 3의 배수는 모두 제외한다. [2, 3, 5, 7, 11, 13, 17, 19, 23, 25]
##### step 3
남은 수 중에서 아직 처리하지 않은 가장 작은 수를 찾은 다음, 그 수를 제외한 배수를 제거한다. 따라서 5를 제외한 5의 배수는 모두 제외한다. [2, 3, 5, 7, 11, 13, 17, 19, 23]
##### step 4
이어서 마찬가지로, 남은 수 중에서 가장 작은 수를 찾은 다음, 그 수를 제외한 배수를 제거하는 과정을 반복한다. 이 과정을 거쳐 남아 있는 수는 모두 소수이며, 이렇게 2부터 26까지의 모든 소수를 찾았다. 최종적인 결과는 다음과 같다. [2, 3, 5, 7, 11, 13, 17, 19, 23]

에라토스테네스의 체 알고리즘을 이용하여 1부터 N까지의 모든 소수를 출력하는 프로그램을 작성하면 다음과 같다. 예제에서는 N = 1,000으로 설정하였다. 또한 매 스텝마다 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다고 하였으나, 이때 i는 **N의 제곱근(가운데 약수)까지만 증가시켜 확인**하면 된다. 그리고 가끔씩 문제에서 1이 소수인지 판별해야 하도록 입력 조건이 주어질 수 있는데, 1은 소수가 아니므로 그런 경우에는 다음 소스코드에 array[1]의 값으로 false 를 넣어주는 부분을 추가해주면 된다.

##### 에라토스테네스의 체.swift
```swift
import Foundation

let n = 1000 // 2부터 1,000까지의 모든 수에 대하여 소수 판별
var array = [Bool](repeating: true, count: n + 1) // 처음엔 모든 수가 소수(true)인 것으로 초기화 (0과 1 제외)

// 에라토스테네스의 체 알고리즘
for i in 2..<Int(sqrt(Double(n)) + 1) { // 2부터 n의 제곱근까지의 모든 수를 확인하며
    if array[i] == true { // i가 소수인 경우 (남은 수인 경우)
        // i를 제외한 i의 모든 배수를 지우기
        var j = 2
        while i * j <= n {
            array[i * j] = false
            j += 1
        }
    }
}

// 모든 소수 출력
for i in 2..<n + 1{
    if array[i]{
        print(i, terminator: " ")
    }
}
```
에라토스테네스의 체 알고리즘의 시간 복잡도는 *O(NloglogN)* 으로 사실상 선형 시간에 동작할 정도로 빠르다. 예를 들어 N = 1,000,000일 때 약 4,000,000 정도가 될 것이다.

이처럼 에라토스테네스의 체 알고리즘은 매우 빠르게 동작하기 떄문에 다수의 소수를 찾아야 하는 문제에서 자주 사용된다. 다만, 메모리가 많이 필요하다는 단점이 있다. 알고리즘을 수행할 때 N의 크기만큼 리스트를 할당해야 하기 때문이다. 예를 들어 N = 1,000,000일 때는 2부터 1,000,000 까지의 모든 수에 대한 정보를 담을 수 있는 크기의 리스트가 필요하다. 또한 10억이 소수인지 찾아야 하는 문제에서는 에라토스테네스의 체를 이용하기 어렵다.

따라서 에라토스테네스의 체를 이용해야 되는 문제의 경우 N이 1,000,000 이내로 주어지는 경우가 많다. 그렇게 하면 이론산 400만번 정도의 연산으로 문제를 해결할 수 있으며, 메모리 또한 충분이 처리할 수 있는 크기만큼만 차지하기 때문이다.
